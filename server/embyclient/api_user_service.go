/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UserServiceAPIService UserServiceAPI service
type UserServiceAPIService service

type UserServiceAPIDeleteUsersByIdRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
}

func (r UserServiceAPIDeleteUsersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUsersByIdExecute(r)
}

/*
DeleteUsersById Deletes a user

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIDeleteUsersByIdRequest
*/
func (a *UserServiceAPIService) DeleteUsersById(ctx context.Context, id string) UserServiceAPIDeleteUsersByIdRequest {
	return UserServiceAPIDeleteUsersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) DeleteUsersByIdExecute(r UserServiceAPIDeleteUsersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.DeleteUsersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIDeleteUsersByIdTrackselectionsByTracktypeRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	trackType string
}

func (r UserServiceAPIDeleteUsersByIdTrackselectionsByTracktypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUsersByIdTrackselectionsByTracktypeExecute(r)
}

/*
DeleteUsersByIdTrackselectionsByTracktype Clears audio or subtitle track selections for a user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param trackType
 @return UserServiceAPIDeleteUsersByIdTrackselectionsByTracktypeRequest
*/
func (a *UserServiceAPIService) DeleteUsersByIdTrackselectionsByTracktype(ctx context.Context, id string, trackType string) UserServiceAPIDeleteUsersByIdTrackselectionsByTracktypeRequest {
	return UserServiceAPIDeleteUsersByIdTrackselectionsByTracktypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		trackType: trackType,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) DeleteUsersByIdTrackselectionsByTracktypeExecute(r UserServiceAPIDeleteUsersByIdTrackselectionsByTracktypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.DeleteUsersByIdTrackselectionsByTracktype")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/TrackSelections/{TrackType}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"TrackType"+"}", url.PathEscape(parameterValueToString(r.trackType, "trackType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIGetUsersByIdRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
}

func (r UserServiceAPIGetUsersByIdRequest) Execute() (*ModelUserDto, *http.Response, error) {
	return r.ApiService.GetUsersByIdExecute(r)
}

/*
GetUsersById Gets a user by Id

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIGetUsersByIdRequest
*/
func (a *UserServiceAPIService) GetUsersById(ctx context.Context, id string) UserServiceAPIGetUsersByIdRequest {
	return UserServiceAPIGetUsersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelUserDto
func (a *UserServiceAPIService) GetUsersByIdExecute(r UserServiceAPIGetUsersByIdRequest) (*ModelUserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelUserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsersById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIGetUsersByUseridTypedsettingsByKeyRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	key string
	userId string
}

func (r UserServiceAPIGetUsersByUseridTypedsettingsByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUsersByUseridTypedsettingsByKeyExecute(r)
}

/*
GetUsersByUseridTypedsettingsByKey Gets a typed user setting

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key Key
 @param userId
 @return UserServiceAPIGetUsersByUseridTypedsettingsByKeyRequest
*/
func (a *UserServiceAPIService) GetUsersByUseridTypedsettingsByKey(ctx context.Context, key string, userId string) UserServiceAPIGetUsersByUseridTypedsettingsByKeyRequest {
	return UserServiceAPIGetUsersByUseridTypedsettingsByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		userId: userId,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) GetUsersByUseridTypedsettingsByKeyExecute(r UserServiceAPIGetUsersByUseridTypedsettingsByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsersByUseridTypedsettingsByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/TypedSettings/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIGetUsersPrefixesRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	isHidden *bool
	isDisabled *bool
	startIndex *int32
	limit *int32
	nameStartsWithOrGreater *string
	sortOrder *string
}

// Optional filter by IsHidden&#x3D;true or false
func (r UserServiceAPIGetUsersPrefixesRequest) IsHidden(isHidden bool) UserServiceAPIGetUsersPrefixesRequest {
	r.isHidden = &isHidden
	return r
}

// Optional filter by IsDisabled&#x3D;true or false
func (r UserServiceAPIGetUsersPrefixesRequest) IsDisabled(isDisabled bool) UserServiceAPIGetUsersPrefixesRequest {
	r.isDisabled = &isDisabled
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r UserServiceAPIGetUsersPrefixesRequest) StartIndex(startIndex int32) UserServiceAPIGetUsersPrefixesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r UserServiceAPIGetUsersPrefixesRequest) Limit(limit int32) UserServiceAPIGetUsersPrefixesRequest {
	r.limit = &limit
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r UserServiceAPIGetUsersPrefixesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) UserServiceAPIGetUsersPrefixesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Sort Order - Ascending,Descending
func (r UserServiceAPIGetUsersPrefixesRequest) SortOrder(sortOrder string) UserServiceAPIGetUsersPrefixesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r UserServiceAPIGetUsersPrefixesRequest) Execute() ([]ModelNameIdPair, *http.Response, error) {
	return r.ApiService.GetUsersPrefixesExecute(r)
}

/*
GetUsersPrefixes Gets a list of users

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserServiceAPIGetUsersPrefixesRequest
*/
func (a *UserServiceAPIService) GetUsersPrefixes(ctx context.Context) UserServiceAPIGetUsersPrefixesRequest {
	return UserServiceAPIGetUsersPrefixesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelNameIdPair
func (a *UserServiceAPIService) GetUsersPrefixesExecute(r UserServiceAPIGetUsersPrefixesRequest) ([]ModelNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsersPrefixes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/Prefixes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isHidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHidden", r.isHidden, "")
	}
	if r.isDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsDisabled", r.isDisabled, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIGetUsersPublicRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
}

func (r UserServiceAPIGetUsersPublicRequest) Execute() ([]ModelUserDto, *http.Response, error) {
	return r.ApiService.GetUsersPublicExecute(r)
}

/*
GetUsersPublic Gets a list of publicly visible users for display on a login screen.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserServiceAPIGetUsersPublicRequest
*/
func (a *UserServiceAPIService) GetUsersPublic(ctx context.Context) UserServiceAPIGetUsersPublicRequest {
	return UserServiceAPIGetUsersPublicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelUserDto
func (a *UserServiceAPIService) GetUsersPublicExecute(r UserServiceAPIGetUsersPublicRequest) ([]ModelUserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelUserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsersPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/Public"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIGetUsersQueryRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	isHidden *bool
	isDisabled *bool
	startIndex *int32
	limit *int32
	nameStartsWithOrGreater *string
	sortOrder *string
}

// Optional filter by IsHidden&#x3D;true or false
func (r UserServiceAPIGetUsersQueryRequest) IsHidden(isHidden bool) UserServiceAPIGetUsersQueryRequest {
	r.isHidden = &isHidden
	return r
}

// Optional filter by IsDisabled&#x3D;true or false
func (r UserServiceAPIGetUsersQueryRequest) IsDisabled(isDisabled bool) UserServiceAPIGetUsersQueryRequest {
	r.isDisabled = &isDisabled
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r UserServiceAPIGetUsersQueryRequest) StartIndex(startIndex int32) UserServiceAPIGetUsersQueryRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r UserServiceAPIGetUsersQueryRequest) Limit(limit int32) UserServiceAPIGetUsersQueryRequest {
	r.limit = &limit
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r UserServiceAPIGetUsersQueryRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) UserServiceAPIGetUsersQueryRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Sort Order - Ascending,Descending
func (r UserServiceAPIGetUsersQueryRequest) SortOrder(sortOrder string) UserServiceAPIGetUsersQueryRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r UserServiceAPIGetUsersQueryRequest) Execute() (*ModelQueryResultUserDto, *http.Response, error) {
	return r.ApiService.GetUsersQueryExecute(r)
}

/*
GetUsersQuery Gets a list of users

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserServiceAPIGetUsersQueryRequest
*/
func (a *UserServiceAPIService) GetUsersQuery(ctx context.Context) UserServiceAPIGetUsersQueryRequest {
	return UserServiceAPIGetUsersQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserDto
func (a *UserServiceAPIService) GetUsersQueryExecute(r UserServiceAPIGetUsersQueryRequest) (*ModelQueryResultUserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsersQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/Query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isHidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHidden", r.isHidden, "")
	}
	if r.isDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsDisabled", r.isDisabled, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersAuthenticatebynameRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	xEmbyAuthorization *string
	modelAuthenticateUserByName *ModelAuthenticateUserByName
}

// The authorization header can be either named &#39;Authorization&#39; or &#39;X-Emby-Authorization&#39;.    It must be of the following schema:     Emby UserId&#x3D;\&quot;(guid)\&quot;, Client&#x3D;\&quot;(string)\&quot;, Device&#x3D;\&quot;(string)\&quot;, DeviceId&#x3D;\&quot;(string)\&quot;, Version&#x3D;\&quot;string\&quot;, Token&#x3D;\&quot;(string)\&quot;     Please consult the documentation for further details.
func (r UserServiceAPIPostUsersAuthenticatebynameRequest) XEmbyAuthorization(xEmbyAuthorization string) UserServiceAPIPostUsersAuthenticatebynameRequest {
	r.xEmbyAuthorization = &xEmbyAuthorization
	return r
}

// AuthenticateUserByName
func (r UserServiceAPIPostUsersAuthenticatebynameRequest) ModelAuthenticateUserByName(modelAuthenticateUserByName ModelAuthenticateUserByName) UserServiceAPIPostUsersAuthenticatebynameRequest {
	r.modelAuthenticateUserByName = &modelAuthenticateUserByName
	return r
}

func (r UserServiceAPIPostUsersAuthenticatebynameRequest) Execute() (*ModelAuthenticationAuthenticationResult, *http.Response, error) {
	return r.ApiService.PostUsersAuthenticatebynameExecute(r)
}

/*
PostUsersAuthenticatebyname Authenticates a user

Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
---
Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserServiceAPIPostUsersAuthenticatebynameRequest
*/
func (a *UserServiceAPIService) PostUsersAuthenticatebyname(ctx context.Context) UserServiceAPIPostUsersAuthenticatebynameRequest {
	return UserServiceAPIPostUsersAuthenticatebynameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelAuthenticationAuthenticationResult
func (a *UserServiceAPIService) PostUsersAuthenticatebynameExecute(r UserServiceAPIPostUsersAuthenticatebynameRequest) (*ModelAuthenticationAuthenticationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelAuthenticationAuthenticationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersAuthenticatebyname")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/AuthenticateByName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xEmbyAuthorization == nil {
		return localVarReturnValue, nil, reportError("xEmbyAuthorization is required and must be specified")
	}
	if r.modelAuthenticateUserByName == nil {
		return localVarReturnValue, nil, reportError("modelAuthenticateUserByName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Emby-Authorization", r.xEmbyAuthorization, "")
	// body params
	localVarPostBody = r.modelAuthenticateUserByName
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	modelUserDto *ModelUserDto
}

// UserDto: 
func (r UserServiceAPIPostUsersByIdRequest) ModelUserDto(modelUserDto ModelUserDto) UserServiceAPIPostUsersByIdRequest {
	r.modelUserDto = &modelUserDto
	return r
}

func (r UserServiceAPIPostUsersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdExecute(r)
}

/*
PostUsersById Updates a user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIPostUsersByIdRequest
*/
func (a *UserServiceAPIService) PostUsersById(ctx context.Context, id string) UserServiceAPIPostUsersByIdRequest {
	return UserServiceAPIPostUsersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdExecute(r UserServiceAPIPostUsersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelUserDto == nil {
		return nil, reportError("modelUserDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelUserDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdAuthenticateRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	modelAuthenticateUser *ModelAuthenticateUser
}

// AuthenticateUser
func (r UserServiceAPIPostUsersByIdAuthenticateRequest) ModelAuthenticateUser(modelAuthenticateUser ModelAuthenticateUser) UserServiceAPIPostUsersByIdAuthenticateRequest {
	r.modelAuthenticateUser = &modelAuthenticateUser
	return r
}

func (r UserServiceAPIPostUsersByIdAuthenticateRequest) Execute() (*ModelAuthenticationAuthenticationResult, *http.Response, error) {
	return r.ApiService.PostUsersByIdAuthenticateExecute(r)
}

/*
PostUsersByIdAuthenticate Authenticates a user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIPostUsersByIdAuthenticateRequest
*/
func (a *UserServiceAPIService) PostUsersByIdAuthenticate(ctx context.Context, id string) UserServiceAPIPostUsersByIdAuthenticateRequest {
	return UserServiceAPIPostUsersByIdAuthenticateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelAuthenticationAuthenticationResult
func (a *UserServiceAPIService) PostUsersByIdAuthenticateExecute(r UserServiceAPIPostUsersByIdAuthenticateRequest) (*ModelAuthenticationAuthenticationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelAuthenticationAuthenticationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdAuthenticate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Authenticate"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelAuthenticateUser == nil {
		return localVarReturnValue, nil, reportError("modelAuthenticateUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelAuthenticateUser
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdConfigurationRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	modelUserConfiguration *ModelUserConfiguration
}

// UserConfiguration: 
func (r UserServiceAPIPostUsersByIdConfigurationRequest) ModelUserConfiguration(modelUserConfiguration ModelUserConfiguration) UserServiceAPIPostUsersByIdConfigurationRequest {
	r.modelUserConfiguration = &modelUserConfiguration
	return r
}

func (r UserServiceAPIPostUsersByIdConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdConfigurationExecute(r)
}

/*
PostUsersByIdConfiguration Updates a user configuration

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIPostUsersByIdConfigurationRequest
*/
func (a *UserServiceAPIService) PostUsersByIdConfiguration(ctx context.Context, id string) UserServiceAPIPostUsersByIdConfigurationRequest {
	return UserServiceAPIPostUsersByIdConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdConfigurationExecute(r UserServiceAPIPostUsersByIdConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelUserConfiguration == nil {
		return nil, reportError("modelUserConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelUserConfiguration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdConfigurationPartialRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	body *os.File
}

// Binary stream
func (r UserServiceAPIPostUsersByIdConfigurationPartialRequest) Body(body *os.File) UserServiceAPIPostUsersByIdConfigurationPartialRequest {
	r.body = body
	return r
}

func (r UserServiceAPIPostUsersByIdConfigurationPartialRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdConfigurationPartialExecute(r)
}

/*
PostUsersByIdConfigurationPartial Updates a user configuration

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIPostUsersByIdConfigurationPartialRequest
*/
func (a *UserServiceAPIService) PostUsersByIdConfigurationPartial(ctx context.Context, id string) UserServiceAPIPostUsersByIdConfigurationPartialRequest {
	return UserServiceAPIPostUsersByIdConfigurationPartialRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdConfigurationPartialExecute(r UserServiceAPIPostUsersByIdConfigurationPartialRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdConfigurationPartial")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Configuration/Partial"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdDeleteRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
}

func (r UserServiceAPIPostUsersByIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdDeleteExecute(r)
}

/*
PostUsersByIdDelete Deletes a user

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIPostUsersByIdDeleteRequest
*/
func (a *UserServiceAPIService) PostUsersByIdDelete(ctx context.Context, id string) UserServiceAPIPostUsersByIdDeleteRequest {
	return UserServiceAPIPostUsersByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdDeleteExecute(r UserServiceAPIPostUsersByIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdPasswordRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	modelUpdateUserPassword *ModelUpdateUserPassword
}

// UpdateUserPassword
func (r UserServiceAPIPostUsersByIdPasswordRequest) ModelUpdateUserPassword(modelUpdateUserPassword ModelUpdateUserPassword) UserServiceAPIPostUsersByIdPasswordRequest {
	r.modelUpdateUserPassword = &modelUpdateUserPassword
	return r
}

func (r UserServiceAPIPostUsersByIdPasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdPasswordExecute(r)
}

/*
PostUsersByIdPassword Updates a user's password

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIPostUsersByIdPasswordRequest
*/
func (a *UserServiceAPIService) PostUsersByIdPassword(ctx context.Context, id string) UserServiceAPIPostUsersByIdPasswordRequest {
	return UserServiceAPIPostUsersByIdPasswordRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdPasswordExecute(r UserServiceAPIPostUsersByIdPasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdPassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Password"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelUpdateUserPassword == nil {
		return nil, reportError("modelUpdateUserPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelUpdateUserPassword
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdPolicyRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	modelUserPolicy *ModelUserPolicy
}

// UserPolicy: 
func (r UserServiceAPIPostUsersByIdPolicyRequest) ModelUserPolicy(modelUserPolicy ModelUserPolicy) UserServiceAPIPostUsersByIdPolicyRequest {
	r.modelUserPolicy = &modelUserPolicy
	return r
}

func (r UserServiceAPIPostUsersByIdPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdPolicyExecute(r)
}

/*
PostUsersByIdPolicy Updates a user policy

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return UserServiceAPIPostUsersByIdPolicyRequest
*/
func (a *UserServiceAPIService) PostUsersByIdPolicy(ctx context.Context, id string) UserServiceAPIPostUsersByIdPolicyRequest {
	return UserServiceAPIPostUsersByIdPolicyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdPolicyExecute(r UserServiceAPIPostUsersByIdPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Policy"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelUserPolicy == nil {
		return nil, reportError("modelUserPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelUserPolicy
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByIdTrackselectionsByTracktypeDeleteRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	id string
	trackType string
}

func (r UserServiceAPIPostUsersByIdTrackselectionsByTracktypeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdTrackselectionsByTracktypeDeleteExecute(r)
}

/*
PostUsersByIdTrackselectionsByTracktypeDelete Clears audio or subtitle track selections for a user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param trackType
 @return UserServiceAPIPostUsersByIdTrackselectionsByTracktypeDeleteRequest
*/
func (a *UserServiceAPIService) PostUsersByIdTrackselectionsByTracktypeDelete(ctx context.Context, id string, trackType string) UserServiceAPIPostUsersByIdTrackselectionsByTracktypeDeleteRequest {
	return UserServiceAPIPostUsersByIdTrackselectionsByTracktypeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		trackType: trackType,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdTrackselectionsByTracktypeDeleteExecute(r UserServiceAPIPostUsersByIdTrackselectionsByTracktypeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdTrackselectionsByTracktypeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/TrackSelections/{TrackType}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"TrackType"+"}", url.PathEscape(parameterValueToString(r.trackType, "trackType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	userId string
	key string
	body *os.File
}

// Binary stream
func (r UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest) Body(body *os.File) UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest {
	r.body = body
	return r
}

func (r UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByUseridTypedsettingsByKeyExecute(r)
}

/*
PostUsersByUseridTypedsettingsByKey Updates a typed user setting

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @param key Key
 @return UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest
*/
func (a *UserServiceAPIService) PostUsersByUseridTypedsettingsByKey(ctx context.Context, userId string, key string) UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest {
	return UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		key: key,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByUseridTypedsettingsByKeyExecute(r UserServiceAPIPostUsersByUseridTypedsettingsByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByUseridTypedsettingsByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/TypedSettings/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersForgotpasswordRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	modelForgotPassword *ModelForgotPassword
}

// ForgotPassword
func (r UserServiceAPIPostUsersForgotpasswordRequest) ModelForgotPassword(modelForgotPassword ModelForgotPassword) UserServiceAPIPostUsersForgotpasswordRequest {
	r.modelForgotPassword = &modelForgotPassword
	return r
}

func (r UserServiceAPIPostUsersForgotpasswordRequest) Execute() (*ModelForgotPasswordResult, *http.Response, error) {
	return r.ApiService.PostUsersForgotpasswordExecute(r)
}

/*
PostUsersForgotpassword Initiates the forgot password process for a local user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserServiceAPIPostUsersForgotpasswordRequest
*/
func (a *UserServiceAPIService) PostUsersForgotpassword(ctx context.Context) UserServiceAPIPostUsersForgotpasswordRequest {
	return UserServiceAPIPostUsersForgotpasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelForgotPasswordResult
func (a *UserServiceAPIService) PostUsersForgotpasswordExecute(r UserServiceAPIPostUsersForgotpasswordRequest) (*ModelForgotPasswordResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelForgotPasswordResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersForgotpassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/ForgotPassword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelForgotPassword == nil {
		return localVarReturnValue, nil, reportError("modelForgotPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelForgotPassword
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersForgotpasswordPinRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	modelForgotPasswordPin *ModelForgotPasswordPin
}

// ForgotPasswordPin
func (r UserServiceAPIPostUsersForgotpasswordPinRequest) ModelForgotPasswordPin(modelForgotPasswordPin ModelForgotPasswordPin) UserServiceAPIPostUsersForgotpasswordPinRequest {
	r.modelForgotPasswordPin = &modelForgotPasswordPin
	return r
}

func (r UserServiceAPIPostUsersForgotpasswordPinRequest) Execute() (*ModelPinRedeemResult, *http.Response, error) {
	return r.ApiService.PostUsersForgotpasswordPinExecute(r)
}

/*
PostUsersForgotpasswordPin Redeems a forgot password pin

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserServiceAPIPostUsersForgotpasswordPinRequest
*/
func (a *UserServiceAPIService) PostUsersForgotpasswordPin(ctx context.Context) UserServiceAPIPostUsersForgotpasswordPinRequest {
	return UserServiceAPIPostUsersForgotpasswordPinRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelPinRedeemResult
func (a *UserServiceAPIService) PostUsersForgotpasswordPinExecute(r UserServiceAPIPostUsersForgotpasswordPinRequest) (*ModelPinRedeemResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelPinRedeemResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersForgotpasswordPin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/ForgotPassword/Pin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelForgotPasswordPin == nil {
		return localVarReturnValue, nil, reportError("modelForgotPasswordPin is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelForgotPasswordPin
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserServiceAPIPostUsersNewRequest struct {
	ctx context.Context
	ApiService *UserServiceAPIService
	modelCreateUserByName *ModelCreateUserByName
}

// CreateUserByName
func (r UserServiceAPIPostUsersNewRequest) ModelCreateUserByName(modelCreateUserByName ModelCreateUserByName) UserServiceAPIPostUsersNewRequest {
	r.modelCreateUserByName = &modelCreateUserByName
	return r
}

func (r UserServiceAPIPostUsersNewRequest) Execute() (*ModelUserDto, *http.Response, error) {
	return r.ApiService.PostUsersNewExecute(r)
}

/*
PostUsersNew Creates a user

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserServiceAPIPostUsersNewRequest
*/
func (a *UserServiceAPIService) PostUsersNew(ctx context.Context) UserServiceAPIPostUsersNewRequest {
	return UserServiceAPIPostUsersNewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelUserDto
func (a *UserServiceAPIService) PostUsersNewExecute(r UserServiceAPIPostUsersNewRequest) (*ModelUserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelUserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersNew")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/New"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelCreateUserByName == nil {
		return localVarReturnValue, nil, reportError("modelCreateUserByName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelCreateUserByName
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

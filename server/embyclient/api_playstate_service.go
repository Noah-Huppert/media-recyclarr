/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PlaystateServiceAPIService PlaystateServiceAPI service
type PlaystateServiceAPIService service

type PlaystateServiceAPIDeleteUsersByUseridPlayeditemsByIdRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	id string
}

func (r PlaystateServiceAPIDeleteUsersByUseridPlayeditemsByIdRequest) Execute() (*ModelUserItemDataDto, *http.Response, error) {
	return r.ApiService.DeleteUsersByUseridPlayeditemsByIdExecute(r)
}

/*
DeleteUsersByUseridPlayeditemsById Marks an item as unplayed

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param id Item Id
 @return PlaystateServiceAPIDeleteUsersByUseridPlayeditemsByIdRequest
*/
func (a *PlaystateServiceAPIService) DeleteUsersByUseridPlayeditemsById(ctx context.Context, userId string, id string) PlaystateServiceAPIDeleteUsersByUseridPlayeditemsByIdRequest {
	return PlaystateServiceAPIDeleteUsersByUseridPlayeditemsByIdRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		id: id,
	}
}

// Execute executes the request
//  @return ModelUserItemDataDto
func (a *PlaystateServiceAPIService) DeleteUsersByUseridPlayeditemsByIdExecute(r PlaystateServiceAPIDeleteUsersByUseridPlayeditemsByIdRequest) (*ModelUserItemDataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelUserItemDataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.DeleteUsersByUseridPlayeditemsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/PlayedItems/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	id string
	mediaSourceId *string
	nextMediaType *string
	positionTicks *int64
	liveStreamId *string
	playSessionId *string
}

// The id of the MediaSource
func (r PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest) MediaSourceId(mediaSourceId string) PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The next media type that will play
func (r PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest) NextMediaType(nextMediaType string) PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest {
	r.nextMediaType = &nextMediaType
	return r
}

// Optional. The position, in ticks, where playback stopped. 1ms &#x3D; 10000 ticks.
func (r PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest) PositionTicks(positionTicks int64) PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest {
	r.positionTicks = &positionTicks
	return r
}

func (r PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest) LiveStreamId(liveStreamId string) PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest {
	r.liveStreamId = &liveStreamId
	return r
}

func (r PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest) PlaySessionId(playSessionId string) PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest {
	r.playSessionId = &playSessionId
	return r
}

func (r PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUsersByUseridPlayingitemsByIdExecute(r)
}

/*
DeleteUsersByUseridPlayingitemsById Reports that a user has stopped playing an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param id Item Id
 @return PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest
*/
func (a *PlaystateServiceAPIService) DeleteUsersByUseridPlayingitemsById(ctx context.Context, userId string, id string) PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest {
	return PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		id: id,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) DeleteUsersByUseridPlayingitemsByIdExecute(r PlaystateServiceAPIDeleteUsersByUseridPlayingitemsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.DeleteUsersByUseridPlayingitemsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/PlayingItems/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return nil, reportError("mediaSourceId is required and must be specified")
	}
	if r.nextMediaType == nil {
		return nil, reportError("nextMediaType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "MediaSourceId", r.mediaSourceId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "NextMediaType", r.nextMediaType, "")
	if r.positionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PositionTicks", r.positionTicks, "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LiveStreamId", r.liveStreamId, "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlaySessionId", r.playSessionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostSessionsPlayingRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	modelPlaybackStartInfo *ModelPlaybackStartInfo
}

// PlaybackStartInfo: 
func (r PlaystateServiceAPIPostSessionsPlayingRequest) ModelPlaybackStartInfo(modelPlaybackStartInfo ModelPlaybackStartInfo) PlaystateServiceAPIPostSessionsPlayingRequest {
	r.modelPlaybackStartInfo = &modelPlaybackStartInfo
	return r
}

func (r PlaystateServiceAPIPostSessionsPlayingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsPlayingExecute(r)
}

/*
PostSessionsPlaying Reports playback has started within a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlaystateServiceAPIPostSessionsPlayingRequest
*/
func (a *PlaystateServiceAPIService) PostSessionsPlaying(ctx context.Context) PlaystateServiceAPIPostSessionsPlayingRequest {
	return PlaystateServiceAPIPostSessionsPlayingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostSessionsPlayingExecute(r PlaystateServiceAPIPostSessionsPlayingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostSessionsPlaying")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Playing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelPlaybackStartInfo == nil {
		return nil, reportError("modelPlaybackStartInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelPlaybackStartInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostSessionsPlayingPingRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	playSessionId *string
}

func (r PlaystateServiceAPIPostSessionsPlayingPingRequest) PlaySessionId(playSessionId string) PlaystateServiceAPIPostSessionsPlayingPingRequest {
	r.playSessionId = &playSessionId
	return r
}

func (r PlaystateServiceAPIPostSessionsPlayingPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsPlayingPingExecute(r)
}

/*
PostSessionsPlayingPing Pings a playback session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlaystateServiceAPIPostSessionsPlayingPingRequest
*/
func (a *PlaystateServiceAPIService) PostSessionsPlayingPing(ctx context.Context) PlaystateServiceAPIPostSessionsPlayingPingRequest {
	return PlaystateServiceAPIPostSessionsPlayingPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostSessionsPlayingPingExecute(r PlaystateServiceAPIPostSessionsPlayingPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostSessionsPlayingPing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Playing/Ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlaySessionId", r.playSessionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostSessionsPlayingProgressRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	modelPlaybackProgressInfo *ModelPlaybackProgressInfo
}

// PlaybackProgressInfo: 
func (r PlaystateServiceAPIPostSessionsPlayingProgressRequest) ModelPlaybackProgressInfo(modelPlaybackProgressInfo ModelPlaybackProgressInfo) PlaystateServiceAPIPostSessionsPlayingProgressRequest {
	r.modelPlaybackProgressInfo = &modelPlaybackProgressInfo
	return r
}

func (r PlaystateServiceAPIPostSessionsPlayingProgressRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsPlayingProgressExecute(r)
}

/*
PostSessionsPlayingProgress Reports playback progress within a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlaystateServiceAPIPostSessionsPlayingProgressRequest
*/
func (a *PlaystateServiceAPIService) PostSessionsPlayingProgress(ctx context.Context) PlaystateServiceAPIPostSessionsPlayingProgressRequest {
	return PlaystateServiceAPIPostSessionsPlayingProgressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostSessionsPlayingProgressExecute(r PlaystateServiceAPIPostSessionsPlayingProgressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostSessionsPlayingProgress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Playing/Progress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelPlaybackProgressInfo == nil {
		return nil, reportError("modelPlaybackProgressInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelPlaybackProgressInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostSessionsPlayingStoppedRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	modelPlaybackStopInfo *ModelPlaybackStopInfo
}

// PlaybackStopInfo: 
func (r PlaystateServiceAPIPostSessionsPlayingStoppedRequest) ModelPlaybackStopInfo(modelPlaybackStopInfo ModelPlaybackStopInfo) PlaystateServiceAPIPostSessionsPlayingStoppedRequest {
	r.modelPlaybackStopInfo = &modelPlaybackStopInfo
	return r
}

func (r PlaystateServiceAPIPostSessionsPlayingStoppedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsPlayingStoppedExecute(r)
}

/*
PostSessionsPlayingStopped Reports playback has stopped within a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlaystateServiceAPIPostSessionsPlayingStoppedRequest
*/
func (a *PlaystateServiceAPIService) PostSessionsPlayingStopped(ctx context.Context) PlaystateServiceAPIPostSessionsPlayingStoppedRequest {
	return PlaystateServiceAPIPostSessionsPlayingStoppedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostSessionsPlayingStoppedExecute(r PlaystateServiceAPIPostSessionsPlayingStoppedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostSessionsPlayingStopped")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Playing/Stopped"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelPlaybackStopInfo == nil {
		return nil, reportError("modelPlaybackStopInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelPlaybackStopInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	itemId string
	modelUserItemDataDto *ModelUserItemDataDto
}

// UserItemDataDto: 
func (r PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest) ModelUserItemDataDto(modelUserItemDataDto ModelUserItemDataDto) PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest {
	r.modelUserItemDataDto = &modelUserItemDataDto
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByUseridItemsByItemidUserdataExecute(r)
}

/*
PostUsersByUseridItemsByItemidUserdata Updates userdata for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param itemId
 @return PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest
*/
func (a *PlaystateServiceAPIService) PostUsersByUseridItemsByItemidUserdata(ctx context.Context, userId string, itemId string) PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest {
	return PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		itemId: itemId,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostUsersByUseridItemsByItemidUserdataExecute(r PlaystateServiceAPIPostUsersByUseridItemsByItemidUserdataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostUsersByUseridItemsByItemidUserdata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/Items/{ItemId}/UserData"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ItemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelUserItemDataDto == nil {
		return nil, reportError("modelUserItemDataDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelUserItemDataDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	id string
	datePlayed *string
}

// The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
func (r PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest) DatePlayed(datePlayed string) PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest {
	r.datePlayed = &datePlayed
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest) Execute() (*ModelUserItemDataDto, *http.Response, error) {
	return r.ApiService.PostUsersByUseridPlayeditemsByIdExecute(r)
}

/*
PostUsersByUseridPlayeditemsById Marks an item as played

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param id Item Id
 @return PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest
*/
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayeditemsById(ctx context.Context, userId string, id string) PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest {
	return PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		id: id,
	}
}

// Execute executes the request
//  @return ModelUserItemDataDto
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayeditemsByIdExecute(r PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdRequest) (*ModelUserItemDataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelUserItemDataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostUsersByUseridPlayeditemsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/PlayedItems/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.datePlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DatePlayed", r.datePlayed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdDeleteRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	id string
}

func (r PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdDeleteRequest) Execute() (*ModelUserItemDataDto, *http.Response, error) {
	return r.ApiService.PostUsersByUseridPlayeditemsByIdDeleteExecute(r)
}

/*
PostUsersByUseridPlayeditemsByIdDelete Marks an item as unplayed

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param id Item Id
 @return PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdDeleteRequest
*/
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayeditemsByIdDelete(ctx context.Context, userId string, id string) PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdDeleteRequest {
	return PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		id: id,
	}
}

// Execute executes the request
//  @return ModelUserItemDataDto
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayeditemsByIdDeleteExecute(r PlaystateServiceAPIPostUsersByUseridPlayeditemsByIdDeleteRequest) (*ModelUserItemDataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelUserItemDataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostUsersByUseridPlayeditemsByIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/PlayedItems/{Id}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	id string
	mediaSourceId *string
	canSeek *bool
	audioStreamIndex *int32
	subtitleStreamIndex *int32
	playMethod *ModelPlayMethod
	liveStreamId *string
	playSessionId *string
}

// The id of the MediaSource
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) MediaSourceId(mediaSourceId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Indicates if the client can seek
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) CanSeek(canSeek bool) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	r.canSeek = &canSeek
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) AudioStreamIndex(audioStreamIndex int32) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) SubtitleStreamIndex(subtitleStreamIndex int32) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) PlayMethod(playMethod ModelPlayMethod) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	r.playMethod = &playMethod
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) LiveStreamId(liveStreamId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	r.liveStreamId = &liveStreamId
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) PlaySessionId(playSessionId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	r.playSessionId = &playSessionId
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByUseridPlayingitemsByIdExecute(r)
}

/*
PostUsersByUseridPlayingitemsById Reports that a user has begun playing an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param id Item Id
 @return PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest
*/
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayingitemsById(ctx context.Context, userId string, id string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest {
	return PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		id: id,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayingitemsByIdExecute(r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostUsersByUseridPlayingitemsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/PlayingItems/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return nil, reportError("mediaSourceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "MediaSourceId", r.mediaSourceId, "")
	if r.canSeek != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CanSeek", r.canSeek, "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioStreamIndex", r.audioStreamIndex, "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleStreamIndex", r.subtitleStreamIndex, "")
	}
	if r.playMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlayMethod", r.playMethod, "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LiveStreamId", r.liveStreamId, "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlaySessionId", r.playSessionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	id string
	mediaSourceId *string
	nextMediaType *string
	positionTicks *int64
	liveStreamId *string
	playSessionId *string
}

// The id of the MediaSource
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest) MediaSourceId(mediaSourceId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The next media type that will play
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest) NextMediaType(nextMediaType string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest {
	r.nextMediaType = &nextMediaType
	return r
}

// Optional. The position, in ticks, where playback stopped. 1ms &#x3D; 10000 ticks.
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest) PositionTicks(positionTicks int64) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest {
	r.positionTicks = &positionTicks
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest) LiveStreamId(liveStreamId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest {
	r.liveStreamId = &liveStreamId
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest) PlaySessionId(playSessionId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest {
	r.playSessionId = &playSessionId
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByUseridPlayingitemsByIdDeleteExecute(r)
}

/*
PostUsersByUseridPlayingitemsByIdDelete Reports that a user has stopped playing an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param id Item Id
 @return PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest
*/
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayingitemsByIdDelete(ctx context.Context, userId string, id string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest {
	return PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		id: id,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayingitemsByIdDeleteExecute(r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostUsersByUseridPlayingitemsByIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/PlayingItems/{Id}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return nil, reportError("mediaSourceId is required and must be specified")
	}
	if r.nextMediaType == nil {
		return nil, reportError("nextMediaType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "MediaSourceId", r.mediaSourceId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "NextMediaType", r.nextMediaType, "")
	if r.positionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PositionTicks", r.positionTicks, "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LiveStreamId", r.liveStreamId, "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlaySessionId", r.playSessionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest struct {
	ctx context.Context
	ApiService *PlaystateServiceAPIService
	userId string
	id string
	mediaSourceId *string
	modelApiOnPlaybackProgress *ModelApiOnPlaybackProgress
	positionTicks *int64
	isPaused *bool
	isMuted *bool
	audioStreamIndex *int32
	subtitleStreamIndex *int32
	volumeLevel *int32
	playMethod *ModelPlayMethod
	liveStreamId *string
	playSessionId *string
	repeatMode *ModelRepeatMode
	subtitleOffset *int32
	playbackRate *float64
}

// The id of the MediaSource
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) MediaSourceId(mediaSourceId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// OnPlaybackProgress
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) ModelApiOnPlaybackProgress(modelApiOnPlaybackProgress ModelApiOnPlaybackProgress) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.modelApiOnPlaybackProgress = &modelApiOnPlaybackProgress
	return r
}

// Optional. The current position, in ticks. 1ms &#x3D; 10000 ticks.
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) PositionTicks(positionTicks int64) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.positionTicks = &positionTicks
	return r
}

// Indicates if the player is paused.
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) IsPaused(isPaused bool) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.isPaused = &isPaused
	return r
}

// Indicates if the player is muted.
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) IsMuted(isMuted bool) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.isMuted = &isMuted
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) AudioStreamIndex(audioStreamIndex int32) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) SubtitleStreamIndex(subtitleStreamIndex int32) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Scale of 0-100
func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) VolumeLevel(volumeLevel int32) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.volumeLevel = &volumeLevel
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) PlayMethod(playMethod ModelPlayMethod) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.playMethod = &playMethod
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) LiveStreamId(liveStreamId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.liveStreamId = &liveStreamId
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) PlaySessionId(playSessionId string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.playSessionId = &playSessionId
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) RepeatMode(repeatMode ModelRepeatMode) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.repeatMode = &repeatMode
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) SubtitleOffset(subtitleOffset int32) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.subtitleOffset = &subtitleOffset
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) PlaybackRate(playbackRate float64) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	r.playbackRate = &playbackRate
	return r
}

func (r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByUseridPlayingitemsByIdProgressExecute(r)
}

/*
PostUsersByUseridPlayingitemsByIdProgress Reports a user's playback progress

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User Id
 @param id Item Id
 @return PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest
*/
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayingitemsByIdProgress(ctx context.Context, userId string, id string) PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest {
	return PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		id: id,
	}
}

// Execute executes the request
func (a *PlaystateServiceAPIService) PostUsersByUseridPlayingitemsByIdProgressExecute(r PlaystateServiceAPIPostUsersByUseridPlayingitemsByIdProgressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaystateServiceAPIService.PostUsersByUseridPlayingitemsByIdProgress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserId}/PlayingItems/{Id}/Progress"
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return nil, reportError("mediaSourceId is required and must be specified")
	}
	if r.modelApiOnPlaybackProgress == nil {
		return nil, reportError("modelApiOnPlaybackProgress is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "MediaSourceId", r.mediaSourceId, "")
	if r.positionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PositionTicks", r.positionTicks, "")
	}
	if r.isPaused != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPaused", r.isPaused, "")
	}
	if r.isMuted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMuted", r.isMuted, "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioStreamIndex", r.audioStreamIndex, "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleStreamIndex", r.subtitleStreamIndex, "")
	}
	if r.volumeLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VolumeLevel", r.volumeLevel, "")
	}
	if r.playMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlayMethod", r.playMethod, "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LiveStreamId", r.liveStreamId, "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlaySessionId", r.playSessionId, "")
	}
	if r.repeatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "RepeatMode", r.repeatMode, "")
	}
	if r.subtitleOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleOffset", r.subtitleOffset, "")
	}
	if r.playbackRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlaybackRate", r.playbackRate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelApiOnPlaybackProgress
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

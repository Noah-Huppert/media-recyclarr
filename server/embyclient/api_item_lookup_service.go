/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ItemLookupServiceAPIService ItemLookupServiceAPI service
type ItemLookupServiceAPIService service

type ItemLookupServiceAPIGetItemsByIdExternalidinfosRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	id string
}

func (r ItemLookupServiceAPIGetItemsByIdExternalidinfosRequest) Execute() ([]ModelExternalIdInfo, *http.Response, error) {
	return r.ApiService.GetItemsByIdExternalidinfosExecute(r)
}

/*
GetItemsByIdExternalidinfos Gets external id infos for an item

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ItemLookupServiceAPIGetItemsByIdExternalidinfosRequest
*/
func (a *ItemLookupServiceAPIService) GetItemsByIdExternalidinfos(ctx context.Context, id string) ItemLookupServiceAPIGetItemsByIdExternalidinfosRequest {
	return ItemLookupServiceAPIGetItemsByIdExternalidinfosRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ModelExternalIdInfo
func (a *ItemLookupServiceAPIService) GetItemsByIdExternalidinfosExecute(r ItemLookupServiceAPIGetItemsByIdExternalidinfosRequest) ([]ModelExternalIdInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelExternalIdInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.GetItemsByIdExternalidinfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/ExternalIdInfos"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIGetItemsRemotesearchImageRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	imageUrl *string
	providerName *string
}

// The image url
func (r ItemLookupServiceAPIGetItemsRemotesearchImageRequest) ImageUrl(imageUrl string) ItemLookupServiceAPIGetItemsRemotesearchImageRequest {
	r.imageUrl = &imageUrl
	return r
}

func (r ItemLookupServiceAPIGetItemsRemotesearchImageRequest) ProviderName(providerName string) ItemLookupServiceAPIGetItemsRemotesearchImageRequest {
	r.providerName = &providerName
	return r
}

func (r ItemLookupServiceAPIGetItemsRemotesearchImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsRemotesearchImageExecute(r)
}

/*
GetItemsRemotesearchImage Gets a remote image

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIGetItemsRemotesearchImageRequest
*/
func (a *ItemLookupServiceAPIService) GetItemsRemotesearchImage(ctx context.Context) ItemLookupServiceAPIGetItemsRemotesearchImageRequest {
	return ItemLookupServiceAPIGetItemsRemotesearchImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ItemLookupServiceAPIService) GetItemsRemotesearchImageExecute(r ItemLookupServiceAPIGetItemsRemotesearchImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.GetItemsRemotesearchImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Image"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.imageUrl == nil {
		return nil, reportError("imageUrl is required and must be specified")
	}
	if r.providerName == nil {
		return nil, reportError("providerName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ImageUrl", r.imageUrl, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderName", r.providerName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsMetadataResetRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	itemIds *string
}

// The item ids
func (r ItemLookupServiceAPIPostItemsMetadataResetRequest) ItemIds(itemIds string) ItemLookupServiceAPIPostItemsMetadataResetRequest {
	r.itemIds = &itemIds
	return r
}

func (r ItemLookupServiceAPIPostItemsMetadataResetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsMetadataResetExecute(r)
}

/*
PostItemsMetadataReset Resets metadata for one or more items

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsMetadataResetRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsMetadataReset(ctx context.Context) ItemLookupServiceAPIPostItemsMetadataResetRequest {
	return ItemLookupServiceAPIPostItemsMetadataResetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ItemLookupServiceAPIService) PostItemsMetadataResetExecute(r ItemLookupServiceAPIPostItemsMetadataResetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsMetadataReset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/Metadata/Reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemIds == nil {
		return nil, reportError("itemIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ItemIds", r.itemIds, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	id string
	modelRemoteSearchResult *ModelRemoteSearchResult
	replaceAllImages *bool
}

// RemoteSearchResult: 
func (r ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest) ModelRemoteSearchResult(modelRemoteSearchResult ModelRemoteSearchResult) ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest {
	r.modelRemoteSearchResult = &modelRemoteSearchResult
	return r
}

// Whether or not to replace all images
func (r ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest) ReplaceAllImages(replaceAllImages bool) ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest {
	r.replaceAllImages = &replaceAllImages
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsRemotesearchApplyByIdExecute(r)
}

/*
PostItemsRemotesearchApplyById Applies search criteria to an item and refreshes metadata

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The item id
 @return ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchApplyById(ctx context.Context, id string) ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchApplyByIdExecute(r ItemLookupServiceAPIPostItemsRemotesearchApplyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchApplyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Apply/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchResult == nil {
		return nil, reportError("modelRemoteSearchResult is required and must be specified")
	}

	if r.replaceAllImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ReplaceAllImages", r.replaceAllImages, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchResult
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchBookRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryBookInfo *ModelRemoteSearchQueryBookInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchBookRequest) ModelRemoteSearchQueryBookInfo(modelRemoteSearchQueryBookInfo ModelRemoteSearchQueryBookInfo) ItemLookupServiceAPIPostItemsRemotesearchBookRequest {
	r.modelRemoteSearchQueryBookInfo = &modelRemoteSearchQueryBookInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchBookRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchBookExecute(r)
}

/*
PostItemsRemotesearchBook Method for PostItemsRemotesearchBook

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchBookRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchBook(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchBookRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchBookRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchBookExecute(r ItemLookupServiceAPIPostItemsRemotesearchBookRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchBook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Book"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryBookInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryBookInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryBookInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryItemLookupInfo *ModelRemoteSearchQueryItemLookupInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest) ModelRemoteSearchQueryItemLookupInfo(modelRemoteSearchQueryItemLookupInfo ModelRemoteSearchQueryItemLookupInfo) ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest {
	r.modelRemoteSearchQueryItemLookupInfo = &modelRemoteSearchQueryItemLookupInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchBoxsetExecute(r)
}

/*
PostItemsRemotesearchBoxset Method for PostItemsRemotesearchBoxset

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchBoxset(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchBoxsetExecute(r ItemLookupServiceAPIPostItemsRemotesearchBoxsetRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchBoxset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/BoxSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryItemLookupInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryItemLookupInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryItemLookupInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchGameRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryGameInfo *ModelRemoteSearchQueryGameInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchGameRequest) ModelRemoteSearchQueryGameInfo(modelRemoteSearchQueryGameInfo ModelRemoteSearchQueryGameInfo) ItemLookupServiceAPIPostItemsRemotesearchGameRequest {
	r.modelRemoteSearchQueryGameInfo = &modelRemoteSearchQueryGameInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchGameRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchGameExecute(r)
}

/*
PostItemsRemotesearchGame Method for PostItemsRemotesearchGame

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchGameRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchGame(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchGameRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchGameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchGameExecute(r ItemLookupServiceAPIPostItemsRemotesearchGameRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Game"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryGameInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryGameInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryGameInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchMovieRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryMovieInfo *ModelRemoteSearchQueryMovieInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchMovieRequest) ModelRemoteSearchQueryMovieInfo(modelRemoteSearchQueryMovieInfo ModelRemoteSearchQueryMovieInfo) ItemLookupServiceAPIPostItemsRemotesearchMovieRequest {
	r.modelRemoteSearchQueryMovieInfo = &modelRemoteSearchQueryMovieInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchMovieRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchMovieExecute(r)
}

/*
PostItemsRemotesearchMovie Method for PostItemsRemotesearchMovie

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchMovieRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMovie(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchMovieRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchMovieRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMovieExecute(r ItemLookupServiceAPIPostItemsRemotesearchMovieRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchMovie")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Movie"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryMovieInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryMovieInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryMovieInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryAlbumInfo *ModelRemoteSearchQueryAlbumInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest) ModelRemoteSearchQueryAlbumInfo(modelRemoteSearchQueryAlbumInfo ModelRemoteSearchQueryAlbumInfo) ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest {
	r.modelRemoteSearchQueryAlbumInfo = &modelRemoteSearchQueryAlbumInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchMusicalbumExecute(r)
}

/*
PostItemsRemotesearchMusicalbum Method for PostItemsRemotesearchMusicalbum

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMusicalbum(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMusicalbumExecute(r ItemLookupServiceAPIPostItemsRemotesearchMusicalbumRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchMusicalbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/MusicAlbum"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryAlbumInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryAlbumInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryAlbumInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryArtistInfo *ModelRemoteSearchQueryArtistInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest) ModelRemoteSearchQueryArtistInfo(modelRemoteSearchQueryArtistInfo ModelRemoteSearchQueryArtistInfo) ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest {
	r.modelRemoteSearchQueryArtistInfo = &modelRemoteSearchQueryArtistInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchMusicartistExecute(r)
}

/*
PostItemsRemotesearchMusicartist Method for PostItemsRemotesearchMusicartist

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMusicartist(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMusicartistExecute(r ItemLookupServiceAPIPostItemsRemotesearchMusicartistRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchMusicartist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/MusicArtist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryArtistInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryArtistInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryArtistInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryMusicVideoInfo *ModelRemoteSearchQueryMusicVideoInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest) ModelRemoteSearchQueryMusicVideoInfo(modelRemoteSearchQueryMusicVideoInfo ModelRemoteSearchQueryMusicVideoInfo) ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest {
	r.modelRemoteSearchQueryMusicVideoInfo = &modelRemoteSearchQueryMusicVideoInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchMusicvideoExecute(r)
}

/*
PostItemsRemotesearchMusicvideo Method for PostItemsRemotesearchMusicvideo

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMusicvideo(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchMusicvideoExecute(r ItemLookupServiceAPIPostItemsRemotesearchMusicvideoRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchMusicvideo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/MusicVideo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryMusicVideoInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryMusicVideoInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryMusicVideoInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchPersonRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryPersonLookupInfo *ModelRemoteSearchQueryPersonLookupInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchPersonRequest) ModelRemoteSearchQueryPersonLookupInfo(modelRemoteSearchQueryPersonLookupInfo ModelRemoteSearchQueryPersonLookupInfo) ItemLookupServiceAPIPostItemsRemotesearchPersonRequest {
	r.modelRemoteSearchQueryPersonLookupInfo = &modelRemoteSearchQueryPersonLookupInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchPersonRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchPersonExecute(r)
}

/*
PostItemsRemotesearchPerson Method for PostItemsRemotesearchPerson

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchPersonRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchPerson(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchPersonRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchPersonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchPersonExecute(r ItemLookupServiceAPIPostItemsRemotesearchPersonRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchPerson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Person"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryPersonLookupInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryPersonLookupInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryPersonLookupInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQuerySeriesInfo *ModelRemoteSearchQuerySeriesInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest) ModelRemoteSearchQuerySeriesInfo(modelRemoteSearchQuerySeriesInfo ModelRemoteSearchQuerySeriesInfo) ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest {
	r.modelRemoteSearchQuerySeriesInfo = &modelRemoteSearchQuerySeriesInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchSeriesExecute(r)
}

/*
PostItemsRemotesearchSeries Method for PostItemsRemotesearchSeries

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchSeries(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchSeriesExecute(r ItemLookupServiceAPIPostItemsRemotesearchSeriesRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Series"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQuerySeriesInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQuerySeriesInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQuerySeriesInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest struct {
	ctx context.Context
	ApiService *ItemLookupServiceAPIService
	modelRemoteSearchQueryTrailerInfo *ModelRemoteSearchQueryTrailerInfo
}

// RemoteSearchQuery&#x60;1: 
func (r ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest) ModelRemoteSearchQueryTrailerInfo(modelRemoteSearchQueryTrailerInfo ModelRemoteSearchQueryTrailerInfo) ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest {
	r.modelRemoteSearchQueryTrailerInfo = &modelRemoteSearchQueryTrailerInfo
	return r
}

func (r ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest) Execute() ([]ModelRemoteSearchResult, *http.Response, error) {
	return r.ApiService.PostItemsRemotesearchTrailerExecute(r)
}

/*
PostItemsRemotesearchTrailer Method for PostItemsRemotesearchTrailer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest
*/
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchTrailer(ctx context.Context) ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest {
	return ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelRemoteSearchResult
func (a *ItemLookupServiceAPIService) PostItemsRemotesearchTrailerExecute(r ItemLookupServiceAPIPostItemsRemotesearchTrailerRequest) ([]ModelRemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelRemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupServiceAPIService.PostItemsRemotesearchTrailer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Trailer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelRemoteSearchQueryTrailerInfo == nil {
		return localVarReturnValue, nil, reportError("modelRemoteSearchQueryTrailerInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelRemoteSearchQueryTrailerInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

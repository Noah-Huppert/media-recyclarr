/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SessionsServiceAPIService SessionsServiceAPI service
type SessionsServiceAPIService service

type SessionsServiceAPIDeleteAuthKeysByKeyRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	key string
}

func (r SessionsServiceAPIDeleteAuthKeysByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuthKeysByKeyExecute(r)
}

/*
DeleteAuthKeysByKey Method for DeleteAuthKeysByKey

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key Auth Key
 @return SessionsServiceAPIDeleteAuthKeysByKeyRequest
*/
func (a *SessionsServiceAPIService) DeleteAuthKeysByKey(ctx context.Context, key string) SessionsServiceAPIDeleteAuthKeysByKeyRequest {
	return SessionsServiceAPIDeleteAuthKeysByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) DeleteAuthKeysByKeyExecute(r SessionsServiceAPIDeleteAuthKeysByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.DeleteAuthKeysByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Keys/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIDeleteSessionsByIdUsersByUseridRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	userId string
}

func (r SessionsServiceAPIDeleteSessionsByIdUsersByUseridRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSessionsByIdUsersByUseridExecute(r)
}

/*
DeleteSessionsByIdUsersByUserid Removes an additional user from a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param userId UserId Id
 @return SessionsServiceAPIDeleteSessionsByIdUsersByUseridRequest
*/
func (a *SessionsServiceAPIService) DeleteSessionsByIdUsersByUserid(ctx context.Context, id string, userId string) SessionsServiceAPIDeleteSessionsByIdUsersByUseridRequest {
	return SessionsServiceAPIDeleteSessionsByIdUsersByUseridRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) DeleteSessionsByIdUsersByUseridExecute(r SessionsServiceAPIDeleteSessionsByIdUsersByUseridRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.DeleteSessionsByIdUsersByUserid")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Users/{UserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIGetAuthKeysRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	startIndex *int32
	limit *int32
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r SessionsServiceAPIGetAuthKeysRequest) StartIndex(startIndex int32) SessionsServiceAPIGetAuthKeysRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r SessionsServiceAPIGetAuthKeysRequest) Limit(limit int32) SessionsServiceAPIGetAuthKeysRequest {
	r.limit = &limit
	return r
}

func (r SessionsServiceAPIGetAuthKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAuthKeysExecute(r)
}

/*
GetAuthKeys Method for GetAuthKeys

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIGetAuthKeysRequest
*/
func (a *SessionsServiceAPIService) GetAuthKeys(ctx context.Context) SessionsServiceAPIGetAuthKeysRequest {
	return SessionsServiceAPIGetAuthKeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) GetAuthKeysExecute(r SessionsServiceAPIGetAuthKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.GetAuthKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIGetAuthProvidersRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
}

func (r SessionsServiceAPIGetAuthProvidersRequest) Execute() ([]ModelNameIdPair, *http.Response, error) {
	return r.ApiService.GetAuthProvidersExecute(r)
}

/*
GetAuthProviders Method for GetAuthProviders

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIGetAuthProvidersRequest
*/
func (a *SessionsServiceAPIService) GetAuthProviders(ctx context.Context) SessionsServiceAPIGetAuthProvidersRequest {
	return SessionsServiceAPIGetAuthProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelNameIdPair
func (a *SessionsServiceAPIService) GetAuthProvidersExecute(r SessionsServiceAPIGetAuthProvidersRequest) ([]ModelNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.GetAuthProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionsServiceAPIGetSessionsRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	controllableByUserId *string
	deviceId *string
	id *string
}

// Optional. Filter by sessions that a given user is allowed to remote control.
func (r SessionsServiceAPIGetSessionsRequest) ControllableByUserId(controllableByUserId string) SessionsServiceAPIGetSessionsRequest {
	r.controllableByUserId = &controllableByUserId
	return r
}

// Optional. Filter by device id.
func (r SessionsServiceAPIGetSessionsRequest) DeviceId(deviceId string) SessionsServiceAPIGetSessionsRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Filter by session id.
func (r SessionsServiceAPIGetSessionsRequest) Id(id string) SessionsServiceAPIGetSessionsRequest {
	r.id = &id
	return r
}

func (r SessionsServiceAPIGetSessionsRequest) Execute() ([]ModelSessionSessionInfo, *http.Response, error) {
	return r.ApiService.GetSessionsExecute(r)
}

/*
GetSessions Gets a list of sessions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIGetSessionsRequest
*/
func (a *SessionsServiceAPIService) GetSessions(ctx context.Context) SessionsServiceAPIGetSessionsRequest {
	return SessionsServiceAPIGetSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelSessionSessionInfo
func (a *SessionsServiceAPIService) GetSessionsExecute(r SessionsServiceAPIGetSessionsRequest) ([]ModelSessionSessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelSessionSessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.GetSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.controllableByUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ControllableByUserId", r.controllableByUserId, "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DeviceId", r.deviceId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionsServiceAPIGetSessionsPlayqueueRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id *string
	deviceId *string
}

// Optional. Filter by session id.
func (r SessionsServiceAPIGetSessionsPlayqueueRequest) Id(id string) SessionsServiceAPIGetSessionsPlayqueueRequest {
	r.id = &id
	return r
}

// Optional. Filter by device id.
func (r SessionsServiceAPIGetSessionsPlayqueueRequest) DeviceId(deviceId string) SessionsServiceAPIGetSessionsPlayqueueRequest {
	r.deviceId = &deviceId
	return r
}

func (r SessionsServiceAPIGetSessionsPlayqueueRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetSessionsPlayqueueExecute(r)
}

/*
GetSessionsPlayqueue Gets a the current play queue from a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIGetSessionsPlayqueueRequest
*/
func (a *SessionsServiceAPIService) GetSessionsPlayqueue(ctx context.Context) SessionsServiceAPIGetSessionsPlayqueueRequest {
	return SessionsServiceAPIGetSessionsPlayqueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *SessionsServiceAPIService) GetSessionsPlayqueueExecute(r SessionsServiceAPIGetSessionsPlayqueueRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.GetSessionsPlayqueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/PlayQueue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DeviceId", r.deviceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionsServiceAPIPostAuthKeysRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	app *string
}

// App
func (r SessionsServiceAPIPostAuthKeysRequest) App(app string) SessionsServiceAPIPostAuthKeysRequest {
	r.app = &app
	return r
}

func (r SessionsServiceAPIPostAuthKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAuthKeysExecute(r)
}

/*
PostAuthKeys Method for PostAuthKeys

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIPostAuthKeysRequest
*/
func (a *SessionsServiceAPIService) PostAuthKeys(ctx context.Context) SessionsServiceAPIPostAuthKeysRequest {
	return SessionsServiceAPIPostAuthKeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostAuthKeysExecute(r SessionsServiceAPIPostAuthKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostAuthKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.app == nil {
		return nil, reportError("app is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "App", r.app, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostAuthKeysByKeyDeleteRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	key string
}

func (r SessionsServiceAPIPostAuthKeysByKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAuthKeysByKeyDeleteExecute(r)
}

/*
PostAuthKeysByKeyDelete Method for PostAuthKeysByKeyDelete

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key Auth Key
 @return SessionsServiceAPIPostAuthKeysByKeyDeleteRequest
*/
func (a *SessionsServiceAPIService) PostAuthKeysByKeyDelete(ctx context.Context, key string) SessionsServiceAPIPostAuthKeysByKeyDeleteRequest {
	return SessionsServiceAPIPostAuthKeysByKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostAuthKeysByKeyDeleteExecute(r SessionsServiceAPIPostAuthKeysByKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostAuthKeysByKeyDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Keys/{Key}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdCommandRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	modelGeneralCommand *ModelGeneralCommand
}

// GeneralCommand: 
func (r SessionsServiceAPIPostSessionsByIdCommandRequest) ModelGeneralCommand(modelGeneralCommand ModelGeneralCommand) SessionsServiceAPIPostSessionsByIdCommandRequest {
	r.modelGeneralCommand = &modelGeneralCommand
	return r
}

func (r SessionsServiceAPIPostSessionsByIdCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdCommandExecute(r)
}

/*
PostSessionsByIdCommand Issues a system command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return SessionsServiceAPIPostSessionsByIdCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdCommand(ctx context.Context, id string) SessionsServiceAPIPostSessionsByIdCommandRequest {
	return SessionsServiceAPIPostSessionsByIdCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdCommandExecute(r SessionsServiceAPIPostSessionsByIdCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Command"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelGeneralCommand == nil {
		return nil, reportError("modelGeneralCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelGeneralCommand
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdCommandByCommandRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	command string
}

func (r SessionsServiceAPIPostSessionsByIdCommandByCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdCommandByCommandExecute(r)
}

/*
PostSessionsByIdCommandByCommand Issues a system command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param command The command to send.
 @return SessionsServiceAPIPostSessionsByIdCommandByCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdCommandByCommand(ctx context.Context, id string, command string) SessionsServiceAPIPostSessionsByIdCommandByCommandRequest {
	return SessionsServiceAPIPostSessionsByIdCommandByCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		command: command,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdCommandByCommandExecute(r SessionsServiceAPIPostSessionsByIdCommandByCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdCommandByCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Command/{Command}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdMessageRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	text *string
	header *string
	timeoutMs *int64
}

// The message text.
func (r SessionsServiceAPIPostSessionsByIdMessageRequest) Text(text string) SessionsServiceAPIPostSessionsByIdMessageRequest {
	r.text = &text
	return r
}

// The message header.
func (r SessionsServiceAPIPostSessionsByIdMessageRequest) Header(header string) SessionsServiceAPIPostSessionsByIdMessageRequest {
	r.header = &header
	return r
}

// The message timeout. If omitted the user will have to confirm viewing the message.
func (r SessionsServiceAPIPostSessionsByIdMessageRequest) TimeoutMs(timeoutMs int64) SessionsServiceAPIPostSessionsByIdMessageRequest {
	r.timeoutMs = &timeoutMs
	return r
}

func (r SessionsServiceAPIPostSessionsByIdMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdMessageExecute(r)
}

/*
PostSessionsByIdMessage Issues a command to a client to display a message to the user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return SessionsServiceAPIPostSessionsByIdMessageRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdMessage(ctx context.Context, id string) SessionsServiceAPIPostSessionsByIdMessageRequest {
	return SessionsServiceAPIPostSessionsByIdMessageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdMessageExecute(r SessionsServiceAPIPostSessionsByIdMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Message"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return nil, reportError("text is required and must be specified")
	}
	if r.header == nil {
		return nil, reportError("header is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Text", r.text, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "Header", r.header, "")
	if r.timeoutMs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "TimeoutMs", r.timeoutMs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdPlayingRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	itemIds *[]int64
	playCommand *ModelPlayCommand
	modelPlayRequest *ModelPlayRequest
	startPositionTicks *int64
}

// The ids of the items to play, comma delimited
func (r SessionsServiceAPIPostSessionsByIdPlayingRequest) ItemIds(itemIds []int64) SessionsServiceAPIPostSessionsByIdPlayingRequest {
	r.itemIds = &itemIds
	return r
}

// The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
func (r SessionsServiceAPIPostSessionsByIdPlayingRequest) PlayCommand(playCommand ModelPlayCommand) SessionsServiceAPIPostSessionsByIdPlayingRequest {
	r.playCommand = &playCommand
	return r
}

// PlayRequest: 
func (r SessionsServiceAPIPostSessionsByIdPlayingRequest) ModelPlayRequest(modelPlayRequest ModelPlayRequest) SessionsServiceAPIPostSessionsByIdPlayingRequest {
	r.modelPlayRequest = &modelPlayRequest
	return r
}

// The starting position of the first item.
func (r SessionsServiceAPIPostSessionsByIdPlayingRequest) StartPositionTicks(startPositionTicks int64) SessionsServiceAPIPostSessionsByIdPlayingRequest {
	r.startPositionTicks = &startPositionTicks
	return r
}

func (r SessionsServiceAPIPostSessionsByIdPlayingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdPlayingExecute(r)
}

/*
PostSessionsByIdPlaying Instructs a session to play an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return SessionsServiceAPIPostSessionsByIdPlayingRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdPlaying(ctx context.Context, id string) SessionsServiceAPIPostSessionsByIdPlayingRequest {
	return SessionsServiceAPIPostSessionsByIdPlayingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdPlayingExecute(r SessionsServiceAPIPostSessionsByIdPlayingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdPlaying")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Playing"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemIds == nil {
		return nil, reportError("itemIds is required and must be specified")
	}
	if r.playCommand == nil {
		return nil, reportError("playCommand is required and must be specified")
	}
	if r.modelPlayRequest == nil {
		return nil, reportError("modelPlayRequest is required and must be specified")
	}

	{
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ItemIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ItemIds", t, "multi")
		}
	}
	if r.startPositionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartPositionTicks", r.startPositionTicks, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "PlayCommand", r.playCommand, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelPlayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	command ModelPlaystateCommand
	modelPlaystateRequest *ModelPlaystateRequest
}

// PlaystateRequest: 
func (r SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest) ModelPlaystateRequest(modelPlaystateRequest ModelPlaystateRequest) SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest {
	r.modelPlaystateRequest = &modelPlaystateRequest
	return r
}

func (r SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdPlayingByCommandExecute(r)
}

/*
PostSessionsByIdPlayingByCommand Issues a playstate command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param command
 @return SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdPlayingByCommand(ctx context.Context, id string, command ModelPlaystateCommand) SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest {
	return SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		command: command,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdPlayingByCommandExecute(r SessionsServiceAPIPostSessionsByIdPlayingByCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdPlayingByCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Playing/{Command}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelPlaystateRequest == nil {
		return nil, reportError("modelPlaystateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelPlaystateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdSystemByCommandRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	command string
}

func (r SessionsServiceAPIPostSessionsByIdSystemByCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdSystemByCommandExecute(r)
}

/*
PostSessionsByIdSystemByCommand Issues a system command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param command The command to send.
 @return SessionsServiceAPIPostSessionsByIdSystemByCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdSystemByCommand(ctx context.Context, id string, command string) SessionsServiceAPIPostSessionsByIdSystemByCommandRequest {
	return SessionsServiceAPIPostSessionsByIdSystemByCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		command: command,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdSystemByCommandExecute(r SessionsServiceAPIPostSessionsByIdSystemByCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdSystemByCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/System/{Command}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdUsersByUseridRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	userId string
}

func (r SessionsServiceAPIPostSessionsByIdUsersByUseridRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdUsersByUseridExecute(r)
}

/*
PostSessionsByIdUsersByUserid Adds an additional user to a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param userId UserId Id
 @return SessionsServiceAPIPostSessionsByIdUsersByUseridRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdUsersByUserid(ctx context.Context, id string, userId string) SessionsServiceAPIPostSessionsByIdUsersByUseridRequest {
	return SessionsServiceAPIPostSessionsByIdUsersByUseridRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdUsersByUseridExecute(r SessionsServiceAPIPostSessionsByIdUsersByUseridRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdUsersByUserid")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Users/{UserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdUsersByUseridDeleteRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	userId string
}

func (r SessionsServiceAPIPostSessionsByIdUsersByUseridDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdUsersByUseridDeleteExecute(r)
}

/*
PostSessionsByIdUsersByUseridDelete Removes an additional user from a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param userId UserId Id
 @return SessionsServiceAPIPostSessionsByIdUsersByUseridDeleteRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdUsersByUseridDelete(ctx context.Context, id string, userId string) SessionsServiceAPIPostSessionsByIdUsersByUseridDeleteRequest {
	return SessionsServiceAPIPostSessionsByIdUsersByUseridDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdUsersByUseridDeleteExecute(r SessionsServiceAPIPostSessionsByIdUsersByUseridDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdUsersByUseridDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Users/{UserId}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsByIdViewingRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id string
	itemType *string
	itemId *string
	itemName *string
}

// The type of item to browse to.
func (r SessionsServiceAPIPostSessionsByIdViewingRequest) ItemType(itemType string) SessionsServiceAPIPostSessionsByIdViewingRequest {
	r.itemType = &itemType
	return r
}

// The Id of the item.
func (r SessionsServiceAPIPostSessionsByIdViewingRequest) ItemId(itemId string) SessionsServiceAPIPostSessionsByIdViewingRequest {
	r.itemId = &itemId
	return r
}

// The name of the item.
func (r SessionsServiceAPIPostSessionsByIdViewingRequest) ItemName(itemName string) SessionsServiceAPIPostSessionsByIdViewingRequest {
	r.itemName = &itemName
	return r
}

func (r SessionsServiceAPIPostSessionsByIdViewingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdViewingExecute(r)
}

/*
PostSessionsByIdViewing Instructs a session to browse to an item or view

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return SessionsServiceAPIPostSessionsByIdViewingRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdViewing(ctx context.Context, id string) SessionsServiceAPIPostSessionsByIdViewingRequest {
	return SessionsServiceAPIPostSessionsByIdViewingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdViewingExecute(r SessionsServiceAPIPostSessionsByIdViewingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdViewing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Viewing"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemType == nil {
		return nil, reportError("itemType is required and must be specified")
	}
	if r.itemId == nil {
		return nil, reportError("itemId is required and must be specified")
	}
	if r.itemName == nil {
		return nil, reportError("itemName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ItemType", r.itemType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ItemId", r.itemId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ItemName", r.itemName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsCapabilitiesRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id *string
	playableMediaTypes *string
	supportedCommands *string
	supportsMediaControl *bool
	supportsSync *bool
}

// Session Id
func (r SessionsServiceAPIPostSessionsCapabilitiesRequest) Id(id string) SessionsServiceAPIPostSessionsCapabilitiesRequest {
	r.id = &id
	return r
}

// A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
func (r SessionsServiceAPIPostSessionsCapabilitiesRequest) PlayableMediaTypes(playableMediaTypes string) SessionsServiceAPIPostSessionsCapabilitiesRequest {
	r.playableMediaTypes = &playableMediaTypes
	return r
}

// A list of supported remote control commands, comma delimited
func (r SessionsServiceAPIPostSessionsCapabilitiesRequest) SupportedCommands(supportedCommands string) SessionsServiceAPIPostSessionsCapabilitiesRequest {
	r.supportedCommands = &supportedCommands
	return r
}

// Determines whether media can be played remotely.
func (r SessionsServiceAPIPostSessionsCapabilitiesRequest) SupportsMediaControl(supportsMediaControl bool) SessionsServiceAPIPostSessionsCapabilitiesRequest {
	r.supportsMediaControl = &supportsMediaControl
	return r
}

// Determines whether sync is supported.
func (r SessionsServiceAPIPostSessionsCapabilitiesRequest) SupportsSync(supportsSync bool) SessionsServiceAPIPostSessionsCapabilitiesRequest {
	r.supportsSync = &supportsSync
	return r
}

func (r SessionsServiceAPIPostSessionsCapabilitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsCapabilitiesExecute(r)
}

/*
PostSessionsCapabilities Updates capabilities for a device

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIPostSessionsCapabilitiesRequest
*/
func (a *SessionsServiceAPIService) PostSessionsCapabilities(ctx context.Context) SessionsServiceAPIPostSessionsCapabilitiesRequest {
	return SessionsServiceAPIPostSessionsCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsCapabilitiesExecute(r SessionsServiceAPIPostSessionsCapabilitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsCapabilities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	if r.playableMediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlayableMediaTypes", r.playableMediaTypes, "")
	}
	if r.supportedCommands != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SupportedCommands", r.supportedCommands, "")
	}
	if r.supportsMediaControl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SupportsMediaControl", r.supportsMediaControl, "")
	}
	if r.supportsSync != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SupportsSync", r.supportsSync, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsCapabilitiesFullRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
	id *string
	modelClientCapabilities *ModelClientCapabilities
}

// Session Id
func (r SessionsServiceAPIPostSessionsCapabilitiesFullRequest) Id(id string) SessionsServiceAPIPostSessionsCapabilitiesFullRequest {
	r.id = &id
	return r
}

// ClientCapabilities: 
func (r SessionsServiceAPIPostSessionsCapabilitiesFullRequest) ModelClientCapabilities(modelClientCapabilities ModelClientCapabilities) SessionsServiceAPIPostSessionsCapabilitiesFullRequest {
	r.modelClientCapabilities = &modelClientCapabilities
	return r
}

func (r SessionsServiceAPIPostSessionsCapabilitiesFullRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsCapabilitiesFullExecute(r)
}

/*
PostSessionsCapabilitiesFull Updates capabilities for a device

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIPostSessionsCapabilitiesFullRequest
*/
func (a *SessionsServiceAPIService) PostSessionsCapabilitiesFull(ctx context.Context) SessionsServiceAPIPostSessionsCapabilitiesFullRequest {
	return SessionsServiceAPIPostSessionsCapabilitiesFullRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsCapabilitiesFullExecute(r SessionsServiceAPIPostSessionsCapabilitiesFullRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsCapabilitiesFull")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities/Full"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.modelClientCapabilities == nil {
		return nil, reportError("modelClientCapabilities is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelClientCapabilities
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionsServiceAPIPostSessionsLogoutRequest struct {
	ctx context.Context
	ApiService *SessionsServiceAPIService
}

func (r SessionsServiceAPIPostSessionsLogoutRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsLogoutExecute(r)
}

/*
PostSessionsLogout Reports that a session has ended

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionsServiceAPIPostSessionsLogoutRequest
*/
func (a *SessionsServiceAPIService) PostSessionsLogout(ctx context.Context) SessionsServiceAPIPostSessionsLogoutRequest {
	return SessionsServiceAPIPostSessionsLogoutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsLogoutExecute(r SessionsServiceAPIPostSessionsLogoutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsLogout")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

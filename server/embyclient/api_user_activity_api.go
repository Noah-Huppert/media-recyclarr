/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UserActivityAPIAPIService UserActivityAPIAPI service
type UserActivityAPIAPIService service

type UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	breakdownType string
	userId *string
	days *int32
	endDate *string
}

// User Id
func (r UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) UserId(userId string) UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest {
	r.userId = &userId
	return r
}

// Number of Days
func (r UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) Days(days int32) UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) EndDate(endDate string) UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest {
	r.endDate = &endDate
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsByBreakdowntypeBreakdownreportExecute(r)
}

/*
GetUserUsageStatsByBreakdowntypeBreakdownreport Gets a breakdown of a usage metric

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param breakdownType Breakdown type
 @return UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsByBreakdowntypeBreakdownreport(ctx context.Context, breakdownType string) UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest {
	return UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest{
		ApiService: a,
		ctx: ctx,
		breakdownType: breakdownType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsByBreakdowntypeBreakdownreportExecute(r UserActivityAPIAPIGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsByBreakdowntypeBreakdownreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/{BreakdownType}/BreakdownReport"
	localVarPath = strings.Replace(localVarPath, "{"+"BreakdownType"+"}", url.PathEscape(parameterValueToString(r.breakdownType, "breakdownType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	}
	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	userID string
	date string
	filter *string
}

// Comma separated list of media types to filter (movies,series)
func (r UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest) Filter(filter string) UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest {
	r.filter = &filter
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsByUseridByDateGetitemsExecute(r)
}

/*
GetUserUsageStatsByUseridByDateGetitems Gets activity for {USER} for {Date} formatted as yyyy-MM-dd

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID User Id
 @param date UTC DateTime, Format yyyy-MM-dd
 @return UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsByUseridByDateGetitems(ctx context.Context, userID string, date string) UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest {
	return UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest{
		ApiService: a,
		ctx: ctx,
		userID: userID,
		date: date,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsByUseridByDateGetitemsExecute(r UserActivityAPIAPIGetUserUsageStatsByUseridByDateGetitemsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsByUseridByDateGetitems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/{UserID}/{Date}/GetItems"
	localVarPath = strings.Replace(localVarPath, "{"+"UserID"+"}", url.PathEscape(parameterValueToString(r.userID, "userID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Date"+"}", url.PathEscape(parameterValueToString(r.date, "date")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	id *int32
}

// item id
func (r UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest) Id(id int32) UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest {
	r.id = &id
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsGetItemPathExecute(r)
}

/*
GetUserUsageStatsGetItemPath Get a list of items for type and filtered

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsGetItemPath(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest {
	return UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsGetItemPathExecute(r UserActivityAPIAPIGetUserUsageStatsGetItemPathRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsGetItemPath")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/get_item_path"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	id *int32
}

// item id
func (r UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest) Id(id int32) UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest {
	r.id = &id
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsGetItemStatsExecute(r)
}

/*
GetUserUsageStatsGetItemStats Get a list of items for type and filtered

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsGetItemStats(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest {
	return UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsGetItemStatsExecute(r UserActivityAPIAPIGetUserUsageStatsGetItemStatsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsGetItemStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/get_item_stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsGetItemsRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	filter *string
	itemType *string
	parent *int32
}

// filter string
func (r UserActivityAPIAPIGetUserUsageStatsGetItemsRequest) Filter(filter string) UserActivityAPIAPIGetUserUsageStatsGetItemsRequest {
	r.filter = &filter
	return r
}

// type of items to return
func (r UserActivityAPIAPIGetUserUsageStatsGetItemsRequest) ItemType(itemType string) UserActivityAPIAPIGetUserUsageStatsGetItemsRequest {
	r.itemType = &itemType
	return r
}

// parentid
func (r UserActivityAPIAPIGetUserUsageStatsGetItemsRequest) Parent(parent int32) UserActivityAPIAPIGetUserUsageStatsGetItemsRequest {
	r.parent = &parent
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsGetItemsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsGetItemsExecute(r)
}

/*
GetUserUsageStatsGetItems Get a list of items for type and filtered

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsGetItemsRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsGetItems(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsGetItemsRequest {
	return UserActivityAPIAPIGetUserUsageStatsGetItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsGetItemsExecute(r UserActivityAPIAPIGetUserUsageStatsGetItemsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsGetItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/get_items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.itemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "item_type", r.itemType, "")
	}
	if r.parent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent", r.parent, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	userId *string
	days *int32
	endDate *string
	filter *string
}

// User Id
func (r UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest) UserId(userId string) UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest {
	r.userId = &userId
	return r
}

// Number of Days
func (r UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest) Days(days int32) UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest) EndDate(endDate string) UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of media types to filter (movies,series)
func (r UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest) Filter(filter string) UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest {
	r.filter = &filter
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsHourlyreportExecute(r)
}

/*
GetUserUsageStatsHourlyreport Gets a report of the available activity per hour

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsHourlyreport(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest {
	return UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsHourlyreportExecute(r UserActivityAPIAPIGetUserUsageStatsHourlyreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsHourlyreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/HourlyReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	}
	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	backupfile *string
}

// File name of file to load
func (r UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest) Backupfile(backupfile string) UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest {
	r.backupfile = &backupfile
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsLoadBackupExecute(r)
}

/*
GetUserUsageStatsLoadBackup Loads a backup from a file

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsLoadBackup(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest {
	return UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsLoadBackupExecute(r UserActivityAPIAPIGetUserUsageStatsLoadBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsLoadBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/load_backup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.backupfile == nil {
		return localVarReturnValue, nil, reportError("backupfile is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "backupfile", r.backupfile, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	userId *string
	days *int32
	endDate *string
}

// User Id
func (r UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest) UserId(userId string) UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest {
	r.userId = &userId
	return r
}

// Number of Days
func (r UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest) Days(days int32) UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest) EndDate(endDate string) UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest {
	r.endDate = &endDate
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsMoviesreportExecute(r)
}

/*
GetUserUsageStatsMoviesreport Gets Movies counts

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsMoviesreport(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest {
	return UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsMoviesreportExecute(r UserActivityAPIAPIGetUserUsageStatsMoviesreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsMoviesreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/MoviesReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	}
	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	days *int32
	endDate *string
	filter *string
	dataType *string
}

// Number of Days
func (r UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest) Days(days int32) UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest) EndDate(endDate string) UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of media types to filter (movies,series)
func (r UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest) Filter(filter string) UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest {
	r.filter = &filter
	return r
}

// Data type to return (count,time)
func (r UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest) DataType(dataType string) UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest {
	r.dataType = &dataType
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsPlayactivityExecute(r)
}

/*
GetUserUsageStatsPlayactivity Gets play activity for number of days

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsPlayactivity(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest {
	return UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsPlayactivityExecute(r UserActivityAPIAPIGetUserUsageStatsPlayactivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsPlayactivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/PlayActivity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.dataType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "data_type", r.dataType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsSaveBackupRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
}

func (r UserActivityAPIAPIGetUserUsageStatsSaveBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsSaveBackupExecute(r)
}

/*
GetUserUsageStatsSaveBackup Saves a backup of the playback report data to the backup path

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsSaveBackupRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsSaveBackup(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsSaveBackupRequest {
	return UserActivityAPIAPIGetUserUsageStatsSaveBackupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsSaveBackupExecute(r UserActivityAPIAPIGetUserUsageStatsSaveBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsSaveBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/save_backup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsSessionListRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
}

func (r UserActivityAPIAPIGetUserUsageStatsSessionListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsSessionListExecute(r)
}

/*
GetUserUsageStatsSessionList Gets Session Info

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsSessionListRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsSessionList(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsSessionListRequest {
	return UserActivityAPIAPIGetUserUsageStatsSessionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsSessionListExecute(r UserActivityAPIAPIGetUserUsageStatsSessionListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsSessionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/session_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	userId *string
	days *int32
	endDate *string
}

// User Id
func (r UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest) UserId(userId string) UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest {
	r.userId = &userId
	return r
}

// Number of Days
func (r UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest) Days(days int32) UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest) EndDate(endDate string) UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest {
	r.endDate = &endDate
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsTvshowsreportExecute(r)
}

/*
GetUserUsageStatsTvshowsreport Gets TV Shows counts

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsTvshowsreport(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest {
	return UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsTvshowsreportExecute(r UserActivityAPIAPIGetUserUsageStatsTvshowsreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsTvshowsreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/TvShowsReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	}
	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsTypeFilterListRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
}

func (r UserActivityAPIAPIGetUserUsageStatsTypeFilterListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsTypeFilterListExecute(r)
}

/*
GetUserUsageStatsTypeFilterList Gets types filter list items

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsTypeFilterListRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsTypeFilterList(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsTypeFilterListRequest {
	return UserActivityAPIAPIGetUserUsageStatsTypeFilterListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsTypeFilterListExecute(r UserActivityAPIAPIGetUserUsageStatsTypeFilterListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsTypeFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/type_filter_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsUserActivityRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	days *int32
	endDate *string
}

// Number of Days
func (r UserActivityAPIAPIGetUserUsageStatsUserActivityRequest) Days(days int32) UserActivityAPIAPIGetUserUsageStatsUserActivityRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r UserActivityAPIAPIGetUserUsageStatsUserActivityRequest) EndDate(endDate string) UserActivityAPIAPIGetUserUsageStatsUserActivityRequest {
	r.endDate = &endDate
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsUserActivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserActivityExecute(r)
}

/*
GetUserUsageStatsUserActivity Gets a report of the available activity per hour

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsUserActivityRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserActivity(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsUserActivityRequest {
	return UserActivityAPIAPIGetUserUsageStatsUserActivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserActivityExecute(r UserActivityAPIAPIGetUserUsageStatsUserActivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/user_activity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsUserListRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
}

func (r UserActivityAPIAPIGetUserUsageStatsUserListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserListExecute(r)
}

/*
GetUserUsageStatsUserList Get users

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsUserListRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserList(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsUserListRequest {
	return UserActivityAPIAPIGetUserUsageStatsUserListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserListExecute(r UserActivityAPIAPIGetUserUsageStatsUserListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/user_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsUserManageByActionByIdRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	action string
	id string
}

func (r UserActivityAPIAPIGetUserUsageStatsUserManageByActionByIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserManageByActionByIdExecute(r)
}

/*
GetUserUsageStatsUserManageByActionById Get users

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param action action to perform
 @param id user Id to perform the action on
 @return UserActivityAPIAPIGetUserUsageStatsUserManageByActionByIdRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserManageByActionById(ctx context.Context, action string, id string) UserActivityAPIAPIGetUserUsageStatsUserManageByActionByIdRequest {
	return UserActivityAPIAPIGetUserUsageStatsUserManageByActionByIdRequest{
		ApiService: a,
		ctx: ctx,
		action: action,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserManageByActionByIdExecute(r UserActivityAPIAPIGetUserUsageStatsUserManageByActionByIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserManageByActionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/user_manage/{Action}/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Action"+"}", url.PathEscape(parameterValueToString(r.action, "action")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	userId *string
	aggregateData *bool
	filterName *string
	days *int32
	endDate *string
	filter *string
}

// User Id
func (r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) UserId(userId string) UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest {
	r.userId = &userId
	return r
}

// Aggregate the data to total duration per user per item
func (r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) AggregateData(aggregateData bool) UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest {
	r.aggregateData = &aggregateData
	return r
}

// Name Filter
func (r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) FilterName(filterName string) UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest {
	r.filterName = &filterName
	return r
}

// Number of Days
func (r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) Days(days int32) UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) EndDate(endDate string) UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of media types to filter (movies,series)
func (r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) Filter(filter string) UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest {
	r.filter = &filter
	return r
}

func (r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserplaylistExecute(r)
}

/*
GetUserUsageStatsUserplaylist Gets a report of all played items for a user in a date period

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserplaylist(ctx context.Context) UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest {
	return UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserplaylistExecute(r UserActivityAPIAPIGetUserUsageStatsUserplaylistRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserplaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/UserPlaylist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.aggregateData == nil {
		return localVarReturnValue, nil, reportError("aggregateData is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate_data", r.aggregateData, "")
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_name", r.filterName, "")
	}
	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UserActivityAPIAPIPostUserUsageStatsImportBackupRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	body *os.File
}

// Binary stream
func (r UserActivityAPIAPIPostUserUsageStatsImportBackupRequest) Body(body *os.File) UserActivityAPIAPIPostUserUsageStatsImportBackupRequest {
	r.body = body
	return r
}

func (r UserActivityAPIAPIPostUserUsageStatsImportBackupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUserUsageStatsImportBackupExecute(r)
}

/*
PostUserUsageStatsImportBackup Post a backup for importing

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIPostUserUsageStatsImportBackupRequest
*/
func (a *UserActivityAPIAPIService) PostUserUsageStatsImportBackup(ctx context.Context) UserActivityAPIAPIPostUserUsageStatsImportBackupRequest {
	return UserActivityAPIAPIPostUserUsageStatsImportBackupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserActivityAPIAPIService) PostUserUsageStatsImportBackupExecute(r UserActivityAPIAPIPostUserUsageStatsImportBackupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.PostUserUsageStatsImportBackup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/import_backup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest struct {
	ctx context.Context
	ApiService *UserActivityAPIAPIService
	modelPlaybackReportingApiCustomQuery *ModelPlaybackReportingApiCustomQuery
}

// CustomQuery
func (r UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest) ModelPlaybackReportingApiCustomQuery(modelPlaybackReportingApiCustomQuery ModelPlaybackReportingApiCustomQuery) UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest {
	r.modelPlaybackReportingApiCustomQuery = &modelPlaybackReportingApiCustomQuery
	return r
}

func (r UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostUserUsageStatsSubmitCustomQueryExecute(r)
}

/*
PostUserUsageStatsSubmitCustomQuery Submit an SQL query

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest
*/
func (a *UserActivityAPIAPIService) PostUserUsageStatsSubmitCustomQuery(ctx context.Context) UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest {
	return UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) PostUserUsageStatsSubmitCustomQueryExecute(r UserActivityAPIAPIPostUserUsageStatsSubmitCustomQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.PostUserUsageStatsSubmitCustomQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/submit_custom_query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelPlaybackReportingApiCustomQuery == nil {
		return localVarReturnValue, nil, reportError("modelPlaybackReportingApiCustomQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelPlaybackReportingApiCustomQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TagServiceAPIService TagServiceAPI service
type TagServiceAPIService service

type TagServiceAPIGetArtistsPrefixesRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetArtistsPrefixesRequest) ArtistType(artistType string) TagServiceAPIGetArtistsPrefixesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetArtistsPrefixesRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetArtistsPrefixesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetArtistsPrefixesRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetArtistsPrefixesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetArtistsPrefixesRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MinStartDate(minStartDate string) TagServiceAPIGetArtistsPrefixesRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetArtistsPrefixesRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MinEndDate(minEndDate string) TagServiceAPIGetArtistsPrefixesRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetArtistsPrefixesRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetArtistsPrefixesRequest) MinPlayers(minPlayers int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetArtistsPrefixesRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetArtistsPrefixesRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetArtistsPrefixesRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsHD(isHD bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsUnaired(isUnaired bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetArtistsPrefixesRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetArtistsPrefixesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetArtistsPrefixesRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetArtistsPrefixesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetArtistsPrefixesRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetArtistsPrefixesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetArtistsPrefixesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetArtistsPrefixesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetArtistsPrefixesRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetArtistsPrefixesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasOverview(hasOverview bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetArtistsPrefixesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetArtistsPrefixesRequest) StartIndex(startIndex int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetArtistsPrefixesRequest) Limit(limit int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetArtistsPrefixesRequest) Recursive(recursive bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetArtistsPrefixesRequest) SearchTerm(searchTerm string) TagServiceAPIGetArtistsPrefixesRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetArtistsPrefixesRequest) SortOrder(sortOrder string) TagServiceAPIGetArtistsPrefixesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetArtistsPrefixesRequest) ParentId(parentId string) TagServiceAPIGetArtistsPrefixesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetArtistsPrefixesRequest) Fields(fields string) TagServiceAPIGetArtistsPrefixesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetArtistsPrefixesRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetArtistsPrefixesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetArtistsPrefixesRequest) Filters(filters string) TagServiceAPIGetArtistsPrefixesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsFavorite(isFavorite bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsMovie(isMovie bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsSeries(isSeries bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsFolder(isFolder bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsNews(isNews bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsKids(isKids bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsSports(isSports bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsNew(isNew bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsPremiere(isPremiere bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsRepeat(isRepeat bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetArtistsPrefixesRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetArtistsPrefixesRequest) MediaTypes(mediaTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetArtistsPrefixesRequest) ImageTypes(imageTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetArtistsPrefixesRequest) SortBy(sortBy string) TagServiceAPIGetArtistsPrefixesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsPlayed(isPlayed bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) Genres(genres string) TagServiceAPIGetArtistsPrefixesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) OfficialRatings(officialRatings string) TagServiceAPIGetArtistsPrefixesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) Tags(tags string) TagServiceAPIGetArtistsPrefixesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) ExcludeTags(excludeTags string) TagServiceAPIGetArtistsPrefixesRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) Years(years string) TagServiceAPIGetArtistsPrefixesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetArtistsPrefixesRequest) EnableImages(enableImages bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetArtistsPrefixesRequest) EnableUserData(enableUserData bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetArtistsPrefixesRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetArtistsPrefixesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetArtistsPrefixesRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetArtistsPrefixesRequest) Person(person string) TagServiceAPIGetArtistsPrefixesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetArtistsPrefixesRequest) PersonIds(personIds string) TagServiceAPIGetArtistsPrefixesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetArtistsPrefixesRequest) PersonTypes(personTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) Studios(studios string) TagServiceAPIGetArtistsPrefixesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) StudioIds(studioIds string) TagServiceAPIGetArtistsPrefixesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) Artists(artists string) TagServiceAPIGetArtistsPrefixesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) ArtistIds(artistIds string) TagServiceAPIGetArtistsPrefixesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) Albums(albums string) TagServiceAPIGetArtistsPrefixesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetArtistsPrefixesRequest) Ids(ids string) TagServiceAPIGetArtistsPrefixesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) VideoTypes(videoTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) Containers(containers string) TagServiceAPIGetArtistsPrefixesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetArtistsPrefixesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetArtistsPrefixesRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetArtistsPrefixesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetArtistsPrefixesRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetArtistsPrefixesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetArtistsPrefixesRequest) Path(path string) TagServiceAPIGetArtistsPrefixesRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetArtistsPrefixesRequest) UserId(userId string) TagServiceAPIGetArtistsPrefixesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetArtistsPrefixesRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetArtistsPrefixesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetArtistsPrefixesRequest) IsLocked(isLocked bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetArtistsPrefixesRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetArtistsPrefixesRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetArtistsPrefixesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetArtistsPrefixesRequest) Is3D(is3D bool) TagServiceAPIGetArtistsPrefixesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetArtistsPrefixesRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetArtistsPrefixesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetArtistsPrefixesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetArtistsPrefixesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetArtistsPrefixesRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetArtistsPrefixesRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetArtistsPrefixesRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetArtistsPrefixesRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetArtistsPrefixesRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetArtistsPrefixesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetArtistsPrefixesRequest) NameLessThan(nameLessThan string) TagServiceAPIGetArtistsPrefixesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetArtistsPrefixesRequest) Execute() ([]ModelNameValuePair, *http.Response, error) {
	return r.ApiService.GetArtistsPrefixesExecute(r)
}

/*
GetArtistsPrefixes Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetArtistsPrefixesRequest
*/
func (a *TagServiceAPIService) GetArtistsPrefixes(ctx context.Context) TagServiceAPIGetArtistsPrefixesRequest {
	return TagServiceAPIGetArtistsPrefixesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelNameValuePair
func (a *TagServiceAPIService) GetArtistsPrefixesExecute(r TagServiceAPIGetArtistsPrefixesRequest) ([]ModelNameValuePair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelNameValuePair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetArtistsPrefixes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/Prefixes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetAudiocodecsRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetAudiocodecsRequest) ArtistType(artistType string) TagServiceAPIGetAudiocodecsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetAudiocodecsRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetAudiocodecsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetAudiocodecsRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetAudiocodecsRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetAudiocodecsRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetAudiocodecsRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetAudiocodecsRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetAudiocodecsRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetAudiocodecsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetAudiocodecsRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetAudiocodecsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MinStartDate(minStartDate string) TagServiceAPIGetAudiocodecsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetAudiocodecsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MinEndDate(minEndDate string) TagServiceAPIGetAudiocodecsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetAudiocodecsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetAudiocodecsRequest) MinPlayers(minPlayers int32) TagServiceAPIGetAudiocodecsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetAudiocodecsRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetAudiocodecsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetAudiocodecsRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetAudiocodecsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetAudiocodecsRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetAudiocodecsRequest) IsHD(isHD bool) TagServiceAPIGetAudiocodecsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetAudiocodecsRequest) IsUnaired(isUnaired bool) TagServiceAPIGetAudiocodecsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetAudiocodecsRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetAudiocodecsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetAudiocodecsRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetAudiocodecsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetAudiocodecsRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetAudiocodecsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetAudiocodecsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetAudiocodecsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetAudiocodecsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiocodecsRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetAudiocodecsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetAudiocodecsRequest) HasOverview(hasOverview bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetAudiocodecsRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetAudiocodecsRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetAudiocodecsRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetAudiocodecsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetAudiocodecsRequest) StartIndex(startIndex int32) TagServiceAPIGetAudiocodecsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetAudiocodecsRequest) Limit(limit int32) TagServiceAPIGetAudiocodecsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetAudiocodecsRequest) Recursive(recursive bool) TagServiceAPIGetAudiocodecsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetAudiocodecsRequest) SearchTerm(searchTerm string) TagServiceAPIGetAudiocodecsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetAudiocodecsRequest) SortOrder(sortOrder string) TagServiceAPIGetAudiocodecsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetAudiocodecsRequest) ParentId(parentId string) TagServiceAPIGetAudiocodecsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetAudiocodecsRequest) Fields(fields string) TagServiceAPIGetAudiocodecsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetAudiocodecsRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetAudiocodecsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetAudiocodecsRequest) Filters(filters string) TagServiceAPIGetAudiocodecsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetAudiocodecsRequest) IsFavorite(isFavorite bool) TagServiceAPIGetAudiocodecsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetAudiocodecsRequest) IsMovie(isMovie bool) TagServiceAPIGetAudiocodecsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetAudiocodecsRequest) IsSeries(isSeries bool) TagServiceAPIGetAudiocodecsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetAudiocodecsRequest) IsFolder(isFolder bool) TagServiceAPIGetAudiocodecsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetAudiocodecsRequest) IsNews(isNews bool) TagServiceAPIGetAudiocodecsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetAudiocodecsRequest) IsKids(isKids bool) TagServiceAPIGetAudiocodecsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetAudiocodecsRequest) IsSports(isSports bool) TagServiceAPIGetAudiocodecsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetAudiocodecsRequest) IsNew(isNew bool) TagServiceAPIGetAudiocodecsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetAudiocodecsRequest) IsPremiere(isPremiere bool) TagServiceAPIGetAudiocodecsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetAudiocodecsRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetAudiocodecsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetAudiocodecsRequest) IsRepeat(isRepeat bool) TagServiceAPIGetAudiocodecsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetAudiocodecsRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetAudiocodecsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetAudiocodecsRequest) MediaTypes(mediaTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetAudiocodecsRequest) ImageTypes(imageTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetAudiocodecsRequest) SortBy(sortBy string) TagServiceAPIGetAudiocodecsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetAudiocodecsRequest) IsPlayed(isPlayed bool) TagServiceAPIGetAudiocodecsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) Genres(genres string) TagServiceAPIGetAudiocodecsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) OfficialRatings(officialRatings string) TagServiceAPIGetAudiocodecsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) Tags(tags string) TagServiceAPIGetAudiocodecsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) ExcludeTags(excludeTags string) TagServiceAPIGetAudiocodecsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) Years(years string) TagServiceAPIGetAudiocodecsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetAudiocodecsRequest) EnableImages(enableImages bool) TagServiceAPIGetAudiocodecsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetAudiocodecsRequest) EnableUserData(enableUserData bool) TagServiceAPIGetAudiocodecsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetAudiocodecsRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetAudiocodecsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetAudiocodecsRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetAudiocodecsRequest) Person(person string) TagServiceAPIGetAudiocodecsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetAudiocodecsRequest) PersonIds(personIds string) TagServiceAPIGetAudiocodecsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetAudiocodecsRequest) PersonTypes(personTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) Studios(studios string) TagServiceAPIGetAudiocodecsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) StudioIds(studioIds string) TagServiceAPIGetAudiocodecsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) Artists(artists string) TagServiceAPIGetAudiocodecsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) ArtistIds(artistIds string) TagServiceAPIGetAudiocodecsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) Albums(albums string) TagServiceAPIGetAudiocodecsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetAudiocodecsRequest) Ids(ids string) TagServiceAPIGetAudiocodecsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) VideoTypes(videoTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) Containers(containers string) TagServiceAPIGetAudiocodecsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetAudiocodecsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetAudiocodecsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetAudiocodecsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetAudiocodecsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetAudiocodecsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetAudiocodecsRequest) Path(path string) TagServiceAPIGetAudiocodecsRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetAudiocodecsRequest) UserId(userId string) TagServiceAPIGetAudiocodecsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetAudiocodecsRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetAudiocodecsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetAudiocodecsRequest) IsLocked(isLocked bool) TagServiceAPIGetAudiocodecsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetAudiocodecsRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetAudiocodecsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetAudiocodecsRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetAudiocodecsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetAudiocodecsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetAudiocodecsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetAudiocodecsRequest) Is3D(is3D bool) TagServiceAPIGetAudiocodecsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiocodecsRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetAudiocodecsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetAudiocodecsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetAudiocodecsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetAudiocodecsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetAudiocodecsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetAudiocodecsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetAudiocodecsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetAudiocodecsRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetAudiocodecsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetAudiocodecsRequest) NameLessThan(nameLessThan string) TagServiceAPIGetAudiocodecsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetAudiocodecsRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetAudiocodecsExecute(r)
}

/*
GetAudiocodecs Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetAudiocodecsRequest
*/
func (a *TagServiceAPIService) GetAudiocodecs(ctx context.Context) TagServiceAPIGetAudiocodecsRequest {
	return TagServiceAPIGetAudiocodecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetAudiocodecsExecute(r TagServiceAPIGetAudiocodecsRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetAudiocodecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/AudioCodecs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetAudiolayoutsRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetAudiolayoutsRequest) ArtistType(artistType string) TagServiceAPIGetAudiolayoutsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetAudiolayoutsRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetAudiolayoutsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetAudiolayoutsRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetAudiolayoutsRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetAudiolayoutsRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetAudiolayoutsRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetAudiolayoutsRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetAudiolayoutsRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetAudiolayoutsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetAudiolayoutsRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetAudiolayoutsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MinStartDate(minStartDate string) TagServiceAPIGetAudiolayoutsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetAudiolayoutsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MinEndDate(minEndDate string) TagServiceAPIGetAudiolayoutsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetAudiolayoutsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetAudiolayoutsRequest) MinPlayers(minPlayers int32) TagServiceAPIGetAudiolayoutsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetAudiolayoutsRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetAudiolayoutsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetAudiolayoutsRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetAudiolayoutsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetAudiolayoutsRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetAudiolayoutsRequest) IsHD(isHD bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetAudiolayoutsRequest) IsUnaired(isUnaired bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetAudiolayoutsRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetAudiolayoutsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetAudiolayoutsRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetAudiolayoutsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetAudiolayoutsRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetAudiolayoutsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetAudiolayoutsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetAudiolayoutsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetAudiolayoutsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetAudiolayoutsRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetAudiolayoutsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetAudiolayoutsRequest) HasOverview(hasOverview bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetAudiolayoutsRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetAudiolayoutsRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetAudiolayoutsRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetAudiolayoutsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetAudiolayoutsRequest) StartIndex(startIndex int32) TagServiceAPIGetAudiolayoutsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetAudiolayoutsRequest) Limit(limit int32) TagServiceAPIGetAudiolayoutsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetAudiolayoutsRequest) Recursive(recursive bool) TagServiceAPIGetAudiolayoutsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetAudiolayoutsRequest) SearchTerm(searchTerm string) TagServiceAPIGetAudiolayoutsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetAudiolayoutsRequest) SortOrder(sortOrder string) TagServiceAPIGetAudiolayoutsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetAudiolayoutsRequest) ParentId(parentId string) TagServiceAPIGetAudiolayoutsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetAudiolayoutsRequest) Fields(fields string) TagServiceAPIGetAudiolayoutsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetAudiolayoutsRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetAudiolayoutsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetAudiolayoutsRequest) Filters(filters string) TagServiceAPIGetAudiolayoutsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetAudiolayoutsRequest) IsFavorite(isFavorite bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetAudiolayoutsRequest) IsMovie(isMovie bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetAudiolayoutsRequest) IsSeries(isSeries bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetAudiolayoutsRequest) IsFolder(isFolder bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetAudiolayoutsRequest) IsNews(isNews bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetAudiolayoutsRequest) IsKids(isKids bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetAudiolayoutsRequest) IsSports(isSports bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetAudiolayoutsRequest) IsNew(isNew bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetAudiolayoutsRequest) IsPremiere(isPremiere bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetAudiolayoutsRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetAudiolayoutsRequest) IsRepeat(isRepeat bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetAudiolayoutsRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetAudiolayoutsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetAudiolayoutsRequest) MediaTypes(mediaTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetAudiolayoutsRequest) ImageTypes(imageTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetAudiolayoutsRequest) SortBy(sortBy string) TagServiceAPIGetAudiolayoutsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetAudiolayoutsRequest) IsPlayed(isPlayed bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) Genres(genres string) TagServiceAPIGetAudiolayoutsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) OfficialRatings(officialRatings string) TagServiceAPIGetAudiolayoutsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) Tags(tags string) TagServiceAPIGetAudiolayoutsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) ExcludeTags(excludeTags string) TagServiceAPIGetAudiolayoutsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) Years(years string) TagServiceAPIGetAudiolayoutsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetAudiolayoutsRequest) EnableImages(enableImages bool) TagServiceAPIGetAudiolayoutsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetAudiolayoutsRequest) EnableUserData(enableUserData bool) TagServiceAPIGetAudiolayoutsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetAudiolayoutsRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetAudiolayoutsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetAudiolayoutsRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetAudiolayoutsRequest) Person(person string) TagServiceAPIGetAudiolayoutsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetAudiolayoutsRequest) PersonIds(personIds string) TagServiceAPIGetAudiolayoutsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetAudiolayoutsRequest) PersonTypes(personTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) Studios(studios string) TagServiceAPIGetAudiolayoutsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) StudioIds(studioIds string) TagServiceAPIGetAudiolayoutsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) Artists(artists string) TagServiceAPIGetAudiolayoutsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) ArtistIds(artistIds string) TagServiceAPIGetAudiolayoutsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) Albums(albums string) TagServiceAPIGetAudiolayoutsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetAudiolayoutsRequest) Ids(ids string) TagServiceAPIGetAudiolayoutsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) VideoTypes(videoTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) Containers(containers string) TagServiceAPIGetAudiolayoutsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetAudiolayoutsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetAudiolayoutsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetAudiolayoutsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetAudiolayoutsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetAudiolayoutsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetAudiolayoutsRequest) Path(path string) TagServiceAPIGetAudiolayoutsRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetAudiolayoutsRequest) UserId(userId string) TagServiceAPIGetAudiolayoutsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetAudiolayoutsRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetAudiolayoutsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetAudiolayoutsRequest) IsLocked(isLocked bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetAudiolayoutsRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetAudiolayoutsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetAudiolayoutsRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetAudiolayoutsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetAudiolayoutsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetAudiolayoutsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetAudiolayoutsRequest) Is3D(is3D bool) TagServiceAPIGetAudiolayoutsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetAudiolayoutsRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetAudiolayoutsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetAudiolayoutsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetAudiolayoutsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetAudiolayoutsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetAudiolayoutsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetAudiolayoutsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetAudiolayoutsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetAudiolayoutsRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetAudiolayoutsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetAudiolayoutsRequest) NameLessThan(nameLessThan string) TagServiceAPIGetAudiolayoutsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetAudiolayoutsRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetAudiolayoutsExecute(r)
}

/*
GetAudiolayouts Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetAudiolayoutsRequest
*/
func (a *TagServiceAPIService) GetAudiolayouts(ctx context.Context) TagServiceAPIGetAudiolayoutsRequest {
	return TagServiceAPIGetAudiolayoutsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetAudiolayoutsExecute(r TagServiceAPIGetAudiolayoutsRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetAudiolayouts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/AudioLayouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetContainersRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetContainersRequest) ArtistType(artistType string) TagServiceAPIGetContainersRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetContainersRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetContainersRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetContainersRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetContainersRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetContainersRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetContainersRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetContainersRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetContainersRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetContainersRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetContainersRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetContainersRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetContainersRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetContainersRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetContainersRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetContainersRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetContainersRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MinStartDate(minStartDate string) TagServiceAPIGetContainersRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetContainersRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MinEndDate(minEndDate string) TagServiceAPIGetContainersRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetContainersRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetContainersRequest) MinPlayers(minPlayers int32) TagServiceAPIGetContainersRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetContainersRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetContainersRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetContainersRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetContainersRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetContainersRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetContainersRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetContainersRequest) IsHD(isHD bool) TagServiceAPIGetContainersRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetContainersRequest) IsUnaired(isUnaired bool) TagServiceAPIGetContainersRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetContainersRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetContainersRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetContainersRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetContainersRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetContainersRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetContainersRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetContainersRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetContainersRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetContainersRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetContainersRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetContainersRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetContainersRequest) HasOverview(hasOverview bool) TagServiceAPIGetContainersRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetContainersRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetContainersRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetContainersRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetContainersRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetContainersRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetContainersRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetContainersRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetContainersRequest) StartIndex(startIndex int32) TagServiceAPIGetContainersRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetContainersRequest) Limit(limit int32) TagServiceAPIGetContainersRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetContainersRequest) Recursive(recursive bool) TagServiceAPIGetContainersRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetContainersRequest) SearchTerm(searchTerm string) TagServiceAPIGetContainersRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetContainersRequest) SortOrder(sortOrder string) TagServiceAPIGetContainersRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetContainersRequest) ParentId(parentId string) TagServiceAPIGetContainersRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetContainersRequest) Fields(fields string) TagServiceAPIGetContainersRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetContainersRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetContainersRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetContainersRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetContainersRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetContainersRequest) Filters(filters string) TagServiceAPIGetContainersRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetContainersRequest) IsFavorite(isFavorite bool) TagServiceAPIGetContainersRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetContainersRequest) IsMovie(isMovie bool) TagServiceAPIGetContainersRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetContainersRequest) IsSeries(isSeries bool) TagServiceAPIGetContainersRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetContainersRequest) IsFolder(isFolder bool) TagServiceAPIGetContainersRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetContainersRequest) IsNews(isNews bool) TagServiceAPIGetContainersRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetContainersRequest) IsKids(isKids bool) TagServiceAPIGetContainersRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetContainersRequest) IsSports(isSports bool) TagServiceAPIGetContainersRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetContainersRequest) IsNew(isNew bool) TagServiceAPIGetContainersRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetContainersRequest) IsPremiere(isPremiere bool) TagServiceAPIGetContainersRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetContainersRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetContainersRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetContainersRequest) IsRepeat(isRepeat bool) TagServiceAPIGetContainersRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetContainersRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetContainersRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetContainersRequest) MediaTypes(mediaTypes string) TagServiceAPIGetContainersRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetContainersRequest) ImageTypes(imageTypes string) TagServiceAPIGetContainersRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetContainersRequest) SortBy(sortBy string) TagServiceAPIGetContainersRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetContainersRequest) IsPlayed(isPlayed bool) TagServiceAPIGetContainersRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) Genres(genres string) TagServiceAPIGetContainersRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) OfficialRatings(officialRatings string) TagServiceAPIGetContainersRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) Tags(tags string) TagServiceAPIGetContainersRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) ExcludeTags(excludeTags string) TagServiceAPIGetContainersRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) Years(years string) TagServiceAPIGetContainersRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetContainersRequest) EnableImages(enableImages bool) TagServiceAPIGetContainersRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetContainersRequest) EnableUserData(enableUserData bool) TagServiceAPIGetContainersRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetContainersRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetContainersRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetContainersRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetContainersRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetContainersRequest) Person(person string) TagServiceAPIGetContainersRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetContainersRequest) PersonIds(personIds string) TagServiceAPIGetContainersRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetContainersRequest) PersonTypes(personTypes string) TagServiceAPIGetContainersRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) Studios(studios string) TagServiceAPIGetContainersRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) StudioIds(studioIds string) TagServiceAPIGetContainersRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) Artists(artists string) TagServiceAPIGetContainersRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) ArtistIds(artistIds string) TagServiceAPIGetContainersRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetContainersRequest) Albums(albums string) TagServiceAPIGetContainersRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetContainersRequest) Ids(ids string) TagServiceAPIGetContainersRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) VideoTypes(videoTypes string) TagServiceAPIGetContainersRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) Containers(containers string) TagServiceAPIGetContainersRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetContainersRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetContainersRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetContainersRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetContainersRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetContainersRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetContainersRequest) Path(path string) TagServiceAPIGetContainersRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetContainersRequest) UserId(userId string) TagServiceAPIGetContainersRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetContainersRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetContainersRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetContainersRequest) IsLocked(isLocked bool) TagServiceAPIGetContainersRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetContainersRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetContainersRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetContainersRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetContainersRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetContainersRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetContainersRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetContainersRequest) Is3D(is3D bool) TagServiceAPIGetContainersRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetContainersRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetContainersRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetContainersRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetContainersRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetContainersRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetContainersRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetContainersRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetContainersRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetContainersRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetContainersRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetContainersRequest) NameLessThan(nameLessThan string) TagServiceAPIGetContainersRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetContainersRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetContainersExecute(r)
}

/*
GetContainers Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetContainersRequest
*/
func (a *TagServiceAPIService) GetContainers(ctx context.Context) TagServiceAPIGetContainersRequest {
	return TagServiceAPIGetContainersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetContainersExecute(r TagServiceAPIGetContainersRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Containers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetExtendedvideotypesRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetExtendedvideotypesRequest) ArtistType(artistType string) TagServiceAPIGetExtendedvideotypesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetExtendedvideotypesRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetExtendedvideotypesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetExtendedvideotypesRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetExtendedvideotypesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetExtendedvideotypesRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MinStartDate(minStartDate string) TagServiceAPIGetExtendedvideotypesRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetExtendedvideotypesRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MinEndDate(minEndDate string) TagServiceAPIGetExtendedvideotypesRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetExtendedvideotypesRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetExtendedvideotypesRequest) MinPlayers(minPlayers int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetExtendedvideotypesRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetExtendedvideotypesRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetExtendedvideotypesRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsHD(isHD bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsUnaired(isUnaired bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetExtendedvideotypesRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetExtendedvideotypesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetExtendedvideotypesRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetExtendedvideotypesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetExtendedvideotypesRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetExtendedvideotypesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetExtendedvideotypesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetExtendedvideotypesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetExtendedvideotypesRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetExtendedvideotypesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasOverview(hasOverview bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetExtendedvideotypesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetExtendedvideotypesRequest) StartIndex(startIndex int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetExtendedvideotypesRequest) Limit(limit int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetExtendedvideotypesRequest) Recursive(recursive bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetExtendedvideotypesRequest) SearchTerm(searchTerm string) TagServiceAPIGetExtendedvideotypesRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetExtendedvideotypesRequest) SortOrder(sortOrder string) TagServiceAPIGetExtendedvideotypesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetExtendedvideotypesRequest) ParentId(parentId string) TagServiceAPIGetExtendedvideotypesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetExtendedvideotypesRequest) Fields(fields string) TagServiceAPIGetExtendedvideotypesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetExtendedvideotypesRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetExtendedvideotypesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetExtendedvideotypesRequest) Filters(filters string) TagServiceAPIGetExtendedvideotypesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsFavorite(isFavorite bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsMovie(isMovie bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsSeries(isSeries bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsFolder(isFolder bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsNews(isNews bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsKids(isKids bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsSports(isSports bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsNew(isNew bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsPremiere(isPremiere bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsRepeat(isRepeat bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetExtendedvideotypesRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetExtendedvideotypesRequest) MediaTypes(mediaTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetExtendedvideotypesRequest) ImageTypes(imageTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetExtendedvideotypesRequest) SortBy(sortBy string) TagServiceAPIGetExtendedvideotypesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsPlayed(isPlayed bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) Genres(genres string) TagServiceAPIGetExtendedvideotypesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) OfficialRatings(officialRatings string) TagServiceAPIGetExtendedvideotypesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) Tags(tags string) TagServiceAPIGetExtendedvideotypesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) ExcludeTags(excludeTags string) TagServiceAPIGetExtendedvideotypesRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) Years(years string) TagServiceAPIGetExtendedvideotypesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetExtendedvideotypesRequest) EnableImages(enableImages bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetExtendedvideotypesRequest) EnableUserData(enableUserData bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetExtendedvideotypesRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetExtendedvideotypesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetExtendedvideotypesRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetExtendedvideotypesRequest) Person(person string) TagServiceAPIGetExtendedvideotypesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetExtendedvideotypesRequest) PersonIds(personIds string) TagServiceAPIGetExtendedvideotypesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetExtendedvideotypesRequest) PersonTypes(personTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) Studios(studios string) TagServiceAPIGetExtendedvideotypesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) StudioIds(studioIds string) TagServiceAPIGetExtendedvideotypesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) Artists(artists string) TagServiceAPIGetExtendedvideotypesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) ArtistIds(artistIds string) TagServiceAPIGetExtendedvideotypesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) Albums(albums string) TagServiceAPIGetExtendedvideotypesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetExtendedvideotypesRequest) Ids(ids string) TagServiceAPIGetExtendedvideotypesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) VideoTypes(videoTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) Containers(containers string) TagServiceAPIGetExtendedvideotypesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetExtendedvideotypesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetExtendedvideotypesRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetExtendedvideotypesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetExtendedvideotypesRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetExtendedvideotypesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetExtendedvideotypesRequest) Path(path string) TagServiceAPIGetExtendedvideotypesRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetExtendedvideotypesRequest) UserId(userId string) TagServiceAPIGetExtendedvideotypesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetExtendedvideotypesRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetExtendedvideotypesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetExtendedvideotypesRequest) IsLocked(isLocked bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetExtendedvideotypesRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetExtendedvideotypesRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetExtendedvideotypesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetExtendedvideotypesRequest) Is3D(is3D bool) TagServiceAPIGetExtendedvideotypesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetExtendedvideotypesRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetExtendedvideotypesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetExtendedvideotypesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetExtendedvideotypesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetExtendedvideotypesRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetExtendedvideotypesRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetExtendedvideotypesRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetExtendedvideotypesRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetExtendedvideotypesRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetExtendedvideotypesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetExtendedvideotypesRequest) NameLessThan(nameLessThan string) TagServiceAPIGetExtendedvideotypesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetExtendedvideotypesRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetExtendedvideotypesExecute(r)
}

/*
GetExtendedvideotypes Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetExtendedvideotypesRequest
*/
func (a *TagServiceAPIService) GetExtendedvideotypes(ctx context.Context) TagServiceAPIGetExtendedvideotypesRequest {
	return TagServiceAPIGetExtendedvideotypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetExtendedvideotypesExecute(r TagServiceAPIGetExtendedvideotypesRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetExtendedvideotypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ExtendedVideoTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetItemsPrefixesRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetItemsPrefixesRequest) ArtistType(artistType string) TagServiceAPIGetItemsPrefixesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetItemsPrefixesRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetItemsPrefixesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetItemsPrefixesRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetItemsPrefixesRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetItemsPrefixesRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetItemsPrefixesRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetItemsPrefixesRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetItemsPrefixesRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetItemsPrefixesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetItemsPrefixesRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetItemsPrefixesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MinStartDate(minStartDate string) TagServiceAPIGetItemsPrefixesRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetItemsPrefixesRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MinEndDate(minEndDate string) TagServiceAPIGetItemsPrefixesRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetItemsPrefixesRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetItemsPrefixesRequest) MinPlayers(minPlayers int32) TagServiceAPIGetItemsPrefixesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetItemsPrefixesRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetItemsPrefixesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetItemsPrefixesRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetItemsPrefixesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetItemsPrefixesRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetItemsPrefixesRequest) IsHD(isHD bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetItemsPrefixesRequest) IsUnaired(isUnaired bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetItemsPrefixesRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetItemsPrefixesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetItemsPrefixesRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetItemsPrefixesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetItemsPrefixesRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetItemsPrefixesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetItemsPrefixesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetItemsPrefixesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetItemsPrefixesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemsPrefixesRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetItemsPrefixesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetItemsPrefixesRequest) HasOverview(hasOverview bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetItemsPrefixesRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetItemsPrefixesRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetItemsPrefixesRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetItemsPrefixesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetItemsPrefixesRequest) StartIndex(startIndex int32) TagServiceAPIGetItemsPrefixesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetItemsPrefixesRequest) Limit(limit int32) TagServiceAPIGetItemsPrefixesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetItemsPrefixesRequest) Recursive(recursive bool) TagServiceAPIGetItemsPrefixesRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetItemsPrefixesRequest) SearchTerm(searchTerm string) TagServiceAPIGetItemsPrefixesRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetItemsPrefixesRequest) SortOrder(sortOrder string) TagServiceAPIGetItemsPrefixesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetItemsPrefixesRequest) ParentId(parentId string) TagServiceAPIGetItemsPrefixesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetItemsPrefixesRequest) Fields(fields string) TagServiceAPIGetItemsPrefixesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetItemsPrefixesRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetItemsPrefixesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetItemsPrefixesRequest) Filters(filters string) TagServiceAPIGetItemsPrefixesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetItemsPrefixesRequest) IsFavorite(isFavorite bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetItemsPrefixesRequest) IsMovie(isMovie bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetItemsPrefixesRequest) IsSeries(isSeries bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetItemsPrefixesRequest) IsFolder(isFolder bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetItemsPrefixesRequest) IsNews(isNews bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetItemsPrefixesRequest) IsKids(isKids bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetItemsPrefixesRequest) IsSports(isSports bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetItemsPrefixesRequest) IsNew(isNew bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetItemsPrefixesRequest) IsPremiere(isPremiere bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetItemsPrefixesRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetItemsPrefixesRequest) IsRepeat(isRepeat bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetItemsPrefixesRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetItemsPrefixesRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetItemsPrefixesRequest) MediaTypes(mediaTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetItemsPrefixesRequest) ImageTypes(imageTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetItemsPrefixesRequest) SortBy(sortBy string) TagServiceAPIGetItemsPrefixesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetItemsPrefixesRequest) IsPlayed(isPlayed bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) Genres(genres string) TagServiceAPIGetItemsPrefixesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) OfficialRatings(officialRatings string) TagServiceAPIGetItemsPrefixesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) Tags(tags string) TagServiceAPIGetItemsPrefixesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) ExcludeTags(excludeTags string) TagServiceAPIGetItemsPrefixesRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) Years(years string) TagServiceAPIGetItemsPrefixesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetItemsPrefixesRequest) EnableImages(enableImages bool) TagServiceAPIGetItemsPrefixesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetItemsPrefixesRequest) EnableUserData(enableUserData bool) TagServiceAPIGetItemsPrefixesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetItemsPrefixesRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetItemsPrefixesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetItemsPrefixesRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetItemsPrefixesRequest) Person(person string) TagServiceAPIGetItemsPrefixesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetItemsPrefixesRequest) PersonIds(personIds string) TagServiceAPIGetItemsPrefixesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetItemsPrefixesRequest) PersonTypes(personTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) Studios(studios string) TagServiceAPIGetItemsPrefixesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) StudioIds(studioIds string) TagServiceAPIGetItemsPrefixesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) Artists(artists string) TagServiceAPIGetItemsPrefixesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) ArtistIds(artistIds string) TagServiceAPIGetItemsPrefixesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) Albums(albums string) TagServiceAPIGetItemsPrefixesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetItemsPrefixesRequest) Ids(ids string) TagServiceAPIGetItemsPrefixesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) VideoTypes(videoTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) Containers(containers string) TagServiceAPIGetItemsPrefixesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetItemsPrefixesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetItemsPrefixesRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetItemsPrefixesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetItemsPrefixesRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetItemsPrefixesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetItemsPrefixesRequest) Path(path string) TagServiceAPIGetItemsPrefixesRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetItemsPrefixesRequest) UserId(userId string) TagServiceAPIGetItemsPrefixesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetItemsPrefixesRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetItemsPrefixesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetItemsPrefixesRequest) IsLocked(isLocked bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetItemsPrefixesRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetItemsPrefixesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetItemsPrefixesRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetItemsPrefixesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetItemsPrefixesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetItemsPrefixesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetItemsPrefixesRequest) Is3D(is3D bool) TagServiceAPIGetItemsPrefixesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemsPrefixesRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetItemsPrefixesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetItemsPrefixesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetItemsPrefixesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetItemsPrefixesRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetItemsPrefixesRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetItemsPrefixesRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetItemsPrefixesRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetItemsPrefixesRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetItemsPrefixesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetItemsPrefixesRequest) NameLessThan(nameLessThan string) TagServiceAPIGetItemsPrefixesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetItemsPrefixesRequest) Execute() ([]ModelNameValuePair, *http.Response, error) {
	return r.ApiService.GetItemsPrefixesExecute(r)
}

/*
GetItemsPrefixes Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetItemsPrefixesRequest
*/
func (a *TagServiceAPIService) GetItemsPrefixes(ctx context.Context) TagServiceAPIGetItemsPrefixesRequest {
	return TagServiceAPIGetItemsPrefixesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelNameValuePair
func (a *TagServiceAPIService) GetItemsPrefixesExecute(r TagServiceAPIGetItemsPrefixesRequest) ([]ModelNameValuePair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelNameValuePair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetItemsPrefixes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/Prefixes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetItemtypesRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetItemtypesRequest) ArtistType(artistType string) TagServiceAPIGetItemtypesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetItemtypesRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetItemtypesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetItemtypesRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetItemtypesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetItemtypesRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetItemtypesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetItemtypesRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetItemtypesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetItemtypesRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetItemtypesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetItemtypesRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetItemtypesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetItemtypesRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetItemtypesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetItemtypesRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetItemtypesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MinStartDate(minStartDate string) TagServiceAPIGetItemtypesRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetItemtypesRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MinEndDate(minEndDate string) TagServiceAPIGetItemtypesRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetItemtypesRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetItemtypesRequest) MinPlayers(minPlayers int32) TagServiceAPIGetItemtypesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetItemtypesRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetItemtypesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetItemtypesRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetItemtypesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetItemtypesRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetItemtypesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetItemtypesRequest) IsHD(isHD bool) TagServiceAPIGetItemtypesRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetItemtypesRequest) IsUnaired(isUnaired bool) TagServiceAPIGetItemtypesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetItemtypesRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetItemtypesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetItemtypesRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetItemtypesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetItemtypesRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetItemtypesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetItemtypesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetItemtypesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetItemtypesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetItemtypesRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetItemtypesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetItemtypesRequest) HasOverview(hasOverview bool) TagServiceAPIGetItemtypesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetItemtypesRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetItemtypesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetItemtypesRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetItemtypesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetItemtypesRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetItemtypesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetItemtypesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetItemtypesRequest) StartIndex(startIndex int32) TagServiceAPIGetItemtypesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetItemtypesRequest) Limit(limit int32) TagServiceAPIGetItemtypesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetItemtypesRequest) Recursive(recursive bool) TagServiceAPIGetItemtypesRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetItemtypesRequest) SearchTerm(searchTerm string) TagServiceAPIGetItemtypesRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetItemtypesRequest) SortOrder(sortOrder string) TagServiceAPIGetItemtypesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetItemtypesRequest) ParentId(parentId string) TagServiceAPIGetItemtypesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetItemtypesRequest) Fields(fields string) TagServiceAPIGetItemtypesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetItemtypesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetItemtypesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetItemtypesRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetItemtypesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetItemtypesRequest) Filters(filters string) TagServiceAPIGetItemtypesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetItemtypesRequest) IsFavorite(isFavorite bool) TagServiceAPIGetItemtypesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetItemtypesRequest) IsMovie(isMovie bool) TagServiceAPIGetItemtypesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetItemtypesRequest) IsSeries(isSeries bool) TagServiceAPIGetItemtypesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetItemtypesRequest) IsFolder(isFolder bool) TagServiceAPIGetItemtypesRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetItemtypesRequest) IsNews(isNews bool) TagServiceAPIGetItemtypesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetItemtypesRequest) IsKids(isKids bool) TagServiceAPIGetItemtypesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetItemtypesRequest) IsSports(isSports bool) TagServiceAPIGetItemtypesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetItemtypesRequest) IsNew(isNew bool) TagServiceAPIGetItemtypesRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetItemtypesRequest) IsPremiere(isPremiere bool) TagServiceAPIGetItemtypesRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetItemtypesRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetItemtypesRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetItemtypesRequest) IsRepeat(isRepeat bool) TagServiceAPIGetItemtypesRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetItemtypesRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetItemtypesRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetItemtypesRequest) MediaTypes(mediaTypes string) TagServiceAPIGetItemtypesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetItemtypesRequest) ImageTypes(imageTypes string) TagServiceAPIGetItemtypesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetItemtypesRequest) SortBy(sortBy string) TagServiceAPIGetItemtypesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetItemtypesRequest) IsPlayed(isPlayed bool) TagServiceAPIGetItemtypesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) Genres(genres string) TagServiceAPIGetItemtypesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) OfficialRatings(officialRatings string) TagServiceAPIGetItemtypesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) Tags(tags string) TagServiceAPIGetItemtypesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) ExcludeTags(excludeTags string) TagServiceAPIGetItemtypesRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) Years(years string) TagServiceAPIGetItemtypesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetItemtypesRequest) EnableImages(enableImages bool) TagServiceAPIGetItemtypesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetItemtypesRequest) EnableUserData(enableUserData bool) TagServiceAPIGetItemtypesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetItemtypesRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetItemtypesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetItemtypesRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetItemtypesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetItemtypesRequest) Person(person string) TagServiceAPIGetItemtypesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetItemtypesRequest) PersonIds(personIds string) TagServiceAPIGetItemtypesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetItemtypesRequest) PersonTypes(personTypes string) TagServiceAPIGetItemtypesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) Studios(studios string) TagServiceAPIGetItemtypesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) StudioIds(studioIds string) TagServiceAPIGetItemtypesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) Artists(artists string) TagServiceAPIGetItemtypesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) ArtistIds(artistIds string) TagServiceAPIGetItemtypesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetItemtypesRequest) Albums(albums string) TagServiceAPIGetItemtypesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetItemtypesRequest) Ids(ids string) TagServiceAPIGetItemtypesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) VideoTypes(videoTypes string) TagServiceAPIGetItemtypesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) Containers(containers string) TagServiceAPIGetItemtypesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetItemtypesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetItemtypesRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetItemtypesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetItemtypesRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetItemtypesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetItemtypesRequest) Path(path string) TagServiceAPIGetItemtypesRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetItemtypesRequest) UserId(userId string) TagServiceAPIGetItemtypesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetItemtypesRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetItemtypesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetItemtypesRequest) IsLocked(isLocked bool) TagServiceAPIGetItemtypesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetItemtypesRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetItemtypesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetItemtypesRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetItemtypesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetItemtypesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetItemtypesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetItemtypesRequest) Is3D(is3D bool) TagServiceAPIGetItemtypesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetItemtypesRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetItemtypesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetItemtypesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetItemtypesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetItemtypesRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetItemtypesRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetItemtypesRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetItemtypesRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetItemtypesRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetItemtypesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetItemtypesRequest) NameLessThan(nameLessThan string) TagServiceAPIGetItemtypesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetItemtypesRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetItemtypesExecute(r)
}

/*
GetItemtypes Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetItemtypesRequest
*/
func (a *TagServiceAPIService) GetItemtypes(ctx context.Context) TagServiceAPIGetItemtypesRequest {
	return TagServiceAPIGetItemtypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetItemtypesExecute(r TagServiceAPIGetItemtypesRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetItemtypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ItemTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetStreamlanguagesRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetStreamlanguagesRequest) ArtistType(artistType string) TagServiceAPIGetStreamlanguagesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetStreamlanguagesRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetStreamlanguagesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetStreamlanguagesRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetStreamlanguagesRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetStreamlanguagesRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetStreamlanguagesRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetStreamlanguagesRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetStreamlanguagesRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetStreamlanguagesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetStreamlanguagesRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetStreamlanguagesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MinStartDate(minStartDate string) TagServiceAPIGetStreamlanguagesRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetStreamlanguagesRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MinEndDate(minEndDate string) TagServiceAPIGetStreamlanguagesRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetStreamlanguagesRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetStreamlanguagesRequest) MinPlayers(minPlayers int32) TagServiceAPIGetStreamlanguagesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetStreamlanguagesRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetStreamlanguagesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetStreamlanguagesRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetStreamlanguagesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetStreamlanguagesRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetStreamlanguagesRequest) IsHD(isHD bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetStreamlanguagesRequest) IsUnaired(isUnaired bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetStreamlanguagesRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetStreamlanguagesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetStreamlanguagesRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetStreamlanguagesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetStreamlanguagesRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetStreamlanguagesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetStreamlanguagesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetStreamlanguagesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetStreamlanguagesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetStreamlanguagesRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetStreamlanguagesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetStreamlanguagesRequest) HasOverview(hasOverview bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetStreamlanguagesRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetStreamlanguagesRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetStreamlanguagesRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetStreamlanguagesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetStreamlanguagesRequest) StartIndex(startIndex int32) TagServiceAPIGetStreamlanguagesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetStreamlanguagesRequest) Limit(limit int32) TagServiceAPIGetStreamlanguagesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetStreamlanguagesRequest) Recursive(recursive bool) TagServiceAPIGetStreamlanguagesRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetStreamlanguagesRequest) SearchTerm(searchTerm string) TagServiceAPIGetStreamlanguagesRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetStreamlanguagesRequest) SortOrder(sortOrder string) TagServiceAPIGetStreamlanguagesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetStreamlanguagesRequest) ParentId(parentId string) TagServiceAPIGetStreamlanguagesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetStreamlanguagesRequest) Fields(fields string) TagServiceAPIGetStreamlanguagesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetStreamlanguagesRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetStreamlanguagesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetStreamlanguagesRequest) Filters(filters string) TagServiceAPIGetStreamlanguagesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetStreamlanguagesRequest) IsFavorite(isFavorite bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetStreamlanguagesRequest) IsMovie(isMovie bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetStreamlanguagesRequest) IsSeries(isSeries bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetStreamlanguagesRequest) IsFolder(isFolder bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetStreamlanguagesRequest) IsNews(isNews bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetStreamlanguagesRequest) IsKids(isKids bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetStreamlanguagesRequest) IsSports(isSports bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetStreamlanguagesRequest) IsNew(isNew bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetStreamlanguagesRequest) IsPremiere(isPremiere bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetStreamlanguagesRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetStreamlanguagesRequest) IsRepeat(isRepeat bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetStreamlanguagesRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetStreamlanguagesRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetStreamlanguagesRequest) MediaTypes(mediaTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetStreamlanguagesRequest) ImageTypes(imageTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetStreamlanguagesRequest) SortBy(sortBy string) TagServiceAPIGetStreamlanguagesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetStreamlanguagesRequest) IsPlayed(isPlayed bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) Genres(genres string) TagServiceAPIGetStreamlanguagesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) OfficialRatings(officialRatings string) TagServiceAPIGetStreamlanguagesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) Tags(tags string) TagServiceAPIGetStreamlanguagesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) ExcludeTags(excludeTags string) TagServiceAPIGetStreamlanguagesRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) Years(years string) TagServiceAPIGetStreamlanguagesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetStreamlanguagesRequest) EnableImages(enableImages bool) TagServiceAPIGetStreamlanguagesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetStreamlanguagesRequest) EnableUserData(enableUserData bool) TagServiceAPIGetStreamlanguagesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetStreamlanguagesRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetStreamlanguagesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetStreamlanguagesRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetStreamlanguagesRequest) Person(person string) TagServiceAPIGetStreamlanguagesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetStreamlanguagesRequest) PersonIds(personIds string) TagServiceAPIGetStreamlanguagesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetStreamlanguagesRequest) PersonTypes(personTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) Studios(studios string) TagServiceAPIGetStreamlanguagesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) StudioIds(studioIds string) TagServiceAPIGetStreamlanguagesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) Artists(artists string) TagServiceAPIGetStreamlanguagesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) ArtistIds(artistIds string) TagServiceAPIGetStreamlanguagesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) Albums(albums string) TagServiceAPIGetStreamlanguagesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetStreamlanguagesRequest) Ids(ids string) TagServiceAPIGetStreamlanguagesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) VideoTypes(videoTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) Containers(containers string) TagServiceAPIGetStreamlanguagesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetStreamlanguagesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetStreamlanguagesRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetStreamlanguagesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetStreamlanguagesRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetStreamlanguagesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetStreamlanguagesRequest) Path(path string) TagServiceAPIGetStreamlanguagesRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetStreamlanguagesRequest) UserId(userId string) TagServiceAPIGetStreamlanguagesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetStreamlanguagesRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetStreamlanguagesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetStreamlanguagesRequest) IsLocked(isLocked bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetStreamlanguagesRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetStreamlanguagesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetStreamlanguagesRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetStreamlanguagesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetStreamlanguagesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetStreamlanguagesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetStreamlanguagesRequest) Is3D(is3D bool) TagServiceAPIGetStreamlanguagesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetStreamlanguagesRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetStreamlanguagesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetStreamlanguagesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetStreamlanguagesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetStreamlanguagesRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetStreamlanguagesRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetStreamlanguagesRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetStreamlanguagesRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetStreamlanguagesRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetStreamlanguagesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetStreamlanguagesRequest) NameLessThan(nameLessThan string) TagServiceAPIGetStreamlanguagesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetStreamlanguagesRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetStreamlanguagesExecute(r)
}

/*
GetStreamlanguages Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetStreamlanguagesRequest
*/
func (a *TagServiceAPIService) GetStreamlanguages(ctx context.Context) TagServiceAPIGetStreamlanguagesRequest {
	return TagServiceAPIGetStreamlanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetStreamlanguagesExecute(r TagServiceAPIGetStreamlanguagesRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetStreamlanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/StreamLanguages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetSubtitlecodecsRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetSubtitlecodecsRequest) ArtistType(artistType string) TagServiceAPIGetSubtitlecodecsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetSubtitlecodecsRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetSubtitlecodecsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetSubtitlecodecsRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetSubtitlecodecsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetSubtitlecodecsRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MinStartDate(minStartDate string) TagServiceAPIGetSubtitlecodecsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetSubtitlecodecsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MinEndDate(minEndDate string) TagServiceAPIGetSubtitlecodecsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetSubtitlecodecsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetSubtitlecodecsRequest) MinPlayers(minPlayers int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetSubtitlecodecsRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetSubtitlecodecsRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetSubtitlecodecsRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsHD(isHD bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsUnaired(isUnaired bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetSubtitlecodecsRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetSubtitlecodecsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetSubtitlecodecsRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetSubtitlecodecsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetSubtitlecodecsRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetSubtitlecodecsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetSubtitlecodecsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetSubtitlecodecsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetSubtitlecodecsRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetSubtitlecodecsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasOverview(hasOverview bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetSubtitlecodecsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetSubtitlecodecsRequest) StartIndex(startIndex int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetSubtitlecodecsRequest) Limit(limit int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetSubtitlecodecsRequest) Recursive(recursive bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetSubtitlecodecsRequest) SearchTerm(searchTerm string) TagServiceAPIGetSubtitlecodecsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetSubtitlecodecsRequest) SortOrder(sortOrder string) TagServiceAPIGetSubtitlecodecsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetSubtitlecodecsRequest) ParentId(parentId string) TagServiceAPIGetSubtitlecodecsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetSubtitlecodecsRequest) Fields(fields string) TagServiceAPIGetSubtitlecodecsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetSubtitlecodecsRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetSubtitlecodecsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetSubtitlecodecsRequest) Filters(filters string) TagServiceAPIGetSubtitlecodecsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsFavorite(isFavorite bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsMovie(isMovie bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsSeries(isSeries bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsFolder(isFolder bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsNews(isNews bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsKids(isKids bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsSports(isSports bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsNew(isNew bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsPremiere(isPremiere bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsRepeat(isRepeat bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetSubtitlecodecsRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetSubtitlecodecsRequest) MediaTypes(mediaTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetSubtitlecodecsRequest) ImageTypes(imageTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetSubtitlecodecsRequest) SortBy(sortBy string) TagServiceAPIGetSubtitlecodecsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsPlayed(isPlayed bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) Genres(genres string) TagServiceAPIGetSubtitlecodecsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) OfficialRatings(officialRatings string) TagServiceAPIGetSubtitlecodecsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) Tags(tags string) TagServiceAPIGetSubtitlecodecsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) ExcludeTags(excludeTags string) TagServiceAPIGetSubtitlecodecsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) Years(years string) TagServiceAPIGetSubtitlecodecsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetSubtitlecodecsRequest) EnableImages(enableImages bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetSubtitlecodecsRequest) EnableUserData(enableUserData bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetSubtitlecodecsRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetSubtitlecodecsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetSubtitlecodecsRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetSubtitlecodecsRequest) Person(person string) TagServiceAPIGetSubtitlecodecsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetSubtitlecodecsRequest) PersonIds(personIds string) TagServiceAPIGetSubtitlecodecsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetSubtitlecodecsRequest) PersonTypes(personTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) Studios(studios string) TagServiceAPIGetSubtitlecodecsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) StudioIds(studioIds string) TagServiceAPIGetSubtitlecodecsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) Artists(artists string) TagServiceAPIGetSubtitlecodecsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) ArtistIds(artistIds string) TagServiceAPIGetSubtitlecodecsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) Albums(albums string) TagServiceAPIGetSubtitlecodecsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetSubtitlecodecsRequest) Ids(ids string) TagServiceAPIGetSubtitlecodecsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) VideoTypes(videoTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) Containers(containers string) TagServiceAPIGetSubtitlecodecsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetSubtitlecodecsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetSubtitlecodecsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetSubtitlecodecsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetSubtitlecodecsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetSubtitlecodecsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetSubtitlecodecsRequest) Path(path string) TagServiceAPIGetSubtitlecodecsRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetSubtitlecodecsRequest) UserId(userId string) TagServiceAPIGetSubtitlecodecsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetSubtitlecodecsRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetSubtitlecodecsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetSubtitlecodecsRequest) IsLocked(isLocked bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetSubtitlecodecsRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetSubtitlecodecsRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetSubtitlecodecsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetSubtitlecodecsRequest) Is3D(is3D bool) TagServiceAPIGetSubtitlecodecsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetSubtitlecodecsRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetSubtitlecodecsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetSubtitlecodecsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetSubtitlecodecsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetSubtitlecodecsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetSubtitlecodecsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetSubtitlecodecsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetSubtitlecodecsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetSubtitlecodecsRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetSubtitlecodecsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetSubtitlecodecsRequest) NameLessThan(nameLessThan string) TagServiceAPIGetSubtitlecodecsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetSubtitlecodecsRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetSubtitlecodecsExecute(r)
}

/*
GetSubtitlecodecs Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetSubtitlecodecsRequest
*/
func (a *TagServiceAPIService) GetSubtitlecodecs(ctx context.Context) TagServiceAPIGetSubtitlecodecsRequest {
	return TagServiceAPIGetSubtitlecodecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetSubtitlecodecsExecute(r TagServiceAPIGetSubtitlecodecsRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetSubtitlecodecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SubtitleCodecs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetTagsRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetTagsRequest) ArtistType(artistType string) TagServiceAPIGetTagsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetTagsRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetTagsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetTagsRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetTagsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetTagsRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetTagsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetTagsRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetTagsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetTagsRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetTagsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetTagsRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetTagsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetTagsRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetTagsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetTagsRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetTagsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MinStartDate(minStartDate string) TagServiceAPIGetTagsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetTagsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MinEndDate(minEndDate string) TagServiceAPIGetTagsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetTagsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetTagsRequest) MinPlayers(minPlayers int32) TagServiceAPIGetTagsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetTagsRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetTagsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetTagsRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetTagsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetTagsRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetTagsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetTagsRequest) IsHD(isHD bool) TagServiceAPIGetTagsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetTagsRequest) IsUnaired(isUnaired bool) TagServiceAPIGetTagsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetTagsRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetTagsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetTagsRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetTagsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetTagsRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetTagsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetTagsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetTagsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetTagsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetTagsRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetTagsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetTagsRequest) HasOverview(hasOverview bool) TagServiceAPIGetTagsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetTagsRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetTagsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetTagsRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetTagsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetTagsRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetTagsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetTagsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetTagsRequest) StartIndex(startIndex int32) TagServiceAPIGetTagsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetTagsRequest) Limit(limit int32) TagServiceAPIGetTagsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetTagsRequest) Recursive(recursive bool) TagServiceAPIGetTagsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetTagsRequest) SearchTerm(searchTerm string) TagServiceAPIGetTagsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetTagsRequest) SortOrder(sortOrder string) TagServiceAPIGetTagsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetTagsRequest) ParentId(parentId string) TagServiceAPIGetTagsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetTagsRequest) Fields(fields string) TagServiceAPIGetTagsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetTagsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetTagsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetTagsRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetTagsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetTagsRequest) Filters(filters string) TagServiceAPIGetTagsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetTagsRequest) IsFavorite(isFavorite bool) TagServiceAPIGetTagsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetTagsRequest) IsMovie(isMovie bool) TagServiceAPIGetTagsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetTagsRequest) IsSeries(isSeries bool) TagServiceAPIGetTagsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetTagsRequest) IsFolder(isFolder bool) TagServiceAPIGetTagsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetTagsRequest) IsNews(isNews bool) TagServiceAPIGetTagsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetTagsRequest) IsKids(isKids bool) TagServiceAPIGetTagsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetTagsRequest) IsSports(isSports bool) TagServiceAPIGetTagsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetTagsRequest) IsNew(isNew bool) TagServiceAPIGetTagsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetTagsRequest) IsPremiere(isPremiere bool) TagServiceAPIGetTagsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetTagsRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetTagsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetTagsRequest) IsRepeat(isRepeat bool) TagServiceAPIGetTagsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetTagsRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetTagsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetTagsRequest) MediaTypes(mediaTypes string) TagServiceAPIGetTagsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetTagsRequest) ImageTypes(imageTypes string) TagServiceAPIGetTagsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetTagsRequest) SortBy(sortBy string) TagServiceAPIGetTagsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetTagsRequest) IsPlayed(isPlayed bool) TagServiceAPIGetTagsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) Genres(genres string) TagServiceAPIGetTagsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) OfficialRatings(officialRatings string) TagServiceAPIGetTagsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) Tags(tags string) TagServiceAPIGetTagsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) ExcludeTags(excludeTags string) TagServiceAPIGetTagsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) Years(years string) TagServiceAPIGetTagsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetTagsRequest) EnableImages(enableImages bool) TagServiceAPIGetTagsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetTagsRequest) EnableUserData(enableUserData bool) TagServiceAPIGetTagsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetTagsRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetTagsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetTagsRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetTagsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetTagsRequest) Person(person string) TagServiceAPIGetTagsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetTagsRequest) PersonIds(personIds string) TagServiceAPIGetTagsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetTagsRequest) PersonTypes(personTypes string) TagServiceAPIGetTagsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) Studios(studios string) TagServiceAPIGetTagsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) StudioIds(studioIds string) TagServiceAPIGetTagsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) Artists(artists string) TagServiceAPIGetTagsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) ArtistIds(artistIds string) TagServiceAPIGetTagsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetTagsRequest) Albums(albums string) TagServiceAPIGetTagsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetTagsRequest) Ids(ids string) TagServiceAPIGetTagsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) VideoTypes(videoTypes string) TagServiceAPIGetTagsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) Containers(containers string) TagServiceAPIGetTagsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetTagsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetTagsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetTagsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetTagsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetTagsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetTagsRequest) Path(path string) TagServiceAPIGetTagsRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetTagsRequest) UserId(userId string) TagServiceAPIGetTagsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetTagsRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetTagsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetTagsRequest) IsLocked(isLocked bool) TagServiceAPIGetTagsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetTagsRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetTagsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetTagsRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetTagsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetTagsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetTagsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetTagsRequest) Is3D(is3D bool) TagServiceAPIGetTagsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetTagsRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetTagsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetTagsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetTagsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetTagsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetTagsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetTagsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetTagsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetTagsRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetTagsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetTagsRequest) NameLessThan(nameLessThan string) TagServiceAPIGetTagsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetTagsRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetTagsRequest
*/
func (a *TagServiceAPIService) GetTags(ctx context.Context) TagServiceAPIGetTagsRequest {
	return TagServiceAPIGetTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetTagsExecute(r TagServiceAPIGetTagsRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetVideocodecsRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetVideocodecsRequest) ArtistType(artistType string) TagServiceAPIGetVideocodecsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetVideocodecsRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetVideocodecsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetVideocodecsRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetVideocodecsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetVideocodecsRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetVideocodecsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetVideocodecsRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetVideocodecsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetVideocodecsRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetVideocodecsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetVideocodecsRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetVideocodecsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetVideocodecsRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetVideocodecsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetVideocodecsRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetVideocodecsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MinStartDate(minStartDate string) TagServiceAPIGetVideocodecsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetVideocodecsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MinEndDate(minEndDate string) TagServiceAPIGetVideocodecsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetVideocodecsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetVideocodecsRequest) MinPlayers(minPlayers int32) TagServiceAPIGetVideocodecsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetVideocodecsRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetVideocodecsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetVideocodecsRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetVideocodecsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetVideocodecsRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetVideocodecsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetVideocodecsRequest) IsHD(isHD bool) TagServiceAPIGetVideocodecsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetVideocodecsRequest) IsUnaired(isUnaired bool) TagServiceAPIGetVideocodecsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetVideocodecsRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetVideocodecsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetVideocodecsRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetVideocodecsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetVideocodecsRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetVideocodecsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetVideocodecsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetVideocodecsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetVideocodecsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetVideocodecsRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetVideocodecsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetVideocodecsRequest) HasOverview(hasOverview bool) TagServiceAPIGetVideocodecsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetVideocodecsRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetVideocodecsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetVideocodecsRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetVideocodecsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetVideocodecsRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetVideocodecsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetVideocodecsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetVideocodecsRequest) StartIndex(startIndex int32) TagServiceAPIGetVideocodecsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetVideocodecsRequest) Limit(limit int32) TagServiceAPIGetVideocodecsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetVideocodecsRequest) Recursive(recursive bool) TagServiceAPIGetVideocodecsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetVideocodecsRequest) SearchTerm(searchTerm string) TagServiceAPIGetVideocodecsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetVideocodecsRequest) SortOrder(sortOrder string) TagServiceAPIGetVideocodecsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetVideocodecsRequest) ParentId(parentId string) TagServiceAPIGetVideocodecsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetVideocodecsRequest) Fields(fields string) TagServiceAPIGetVideocodecsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetVideocodecsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetVideocodecsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetVideocodecsRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetVideocodecsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetVideocodecsRequest) Filters(filters string) TagServiceAPIGetVideocodecsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetVideocodecsRequest) IsFavorite(isFavorite bool) TagServiceAPIGetVideocodecsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetVideocodecsRequest) IsMovie(isMovie bool) TagServiceAPIGetVideocodecsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetVideocodecsRequest) IsSeries(isSeries bool) TagServiceAPIGetVideocodecsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetVideocodecsRequest) IsFolder(isFolder bool) TagServiceAPIGetVideocodecsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetVideocodecsRequest) IsNews(isNews bool) TagServiceAPIGetVideocodecsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetVideocodecsRequest) IsKids(isKids bool) TagServiceAPIGetVideocodecsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetVideocodecsRequest) IsSports(isSports bool) TagServiceAPIGetVideocodecsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetVideocodecsRequest) IsNew(isNew bool) TagServiceAPIGetVideocodecsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetVideocodecsRequest) IsPremiere(isPremiere bool) TagServiceAPIGetVideocodecsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetVideocodecsRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetVideocodecsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetVideocodecsRequest) IsRepeat(isRepeat bool) TagServiceAPIGetVideocodecsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetVideocodecsRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetVideocodecsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetVideocodecsRequest) MediaTypes(mediaTypes string) TagServiceAPIGetVideocodecsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetVideocodecsRequest) ImageTypes(imageTypes string) TagServiceAPIGetVideocodecsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetVideocodecsRequest) SortBy(sortBy string) TagServiceAPIGetVideocodecsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetVideocodecsRequest) IsPlayed(isPlayed bool) TagServiceAPIGetVideocodecsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) Genres(genres string) TagServiceAPIGetVideocodecsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) OfficialRatings(officialRatings string) TagServiceAPIGetVideocodecsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) Tags(tags string) TagServiceAPIGetVideocodecsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) ExcludeTags(excludeTags string) TagServiceAPIGetVideocodecsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) Years(years string) TagServiceAPIGetVideocodecsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetVideocodecsRequest) EnableImages(enableImages bool) TagServiceAPIGetVideocodecsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetVideocodecsRequest) EnableUserData(enableUserData bool) TagServiceAPIGetVideocodecsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetVideocodecsRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetVideocodecsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetVideocodecsRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetVideocodecsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetVideocodecsRequest) Person(person string) TagServiceAPIGetVideocodecsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetVideocodecsRequest) PersonIds(personIds string) TagServiceAPIGetVideocodecsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetVideocodecsRequest) PersonTypes(personTypes string) TagServiceAPIGetVideocodecsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) Studios(studios string) TagServiceAPIGetVideocodecsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) StudioIds(studioIds string) TagServiceAPIGetVideocodecsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) Artists(artists string) TagServiceAPIGetVideocodecsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) ArtistIds(artistIds string) TagServiceAPIGetVideocodecsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetVideocodecsRequest) Albums(albums string) TagServiceAPIGetVideocodecsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetVideocodecsRequest) Ids(ids string) TagServiceAPIGetVideocodecsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) VideoTypes(videoTypes string) TagServiceAPIGetVideocodecsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) Containers(containers string) TagServiceAPIGetVideocodecsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetVideocodecsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetVideocodecsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetVideocodecsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetVideocodecsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetVideocodecsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetVideocodecsRequest) Path(path string) TagServiceAPIGetVideocodecsRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetVideocodecsRequest) UserId(userId string) TagServiceAPIGetVideocodecsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetVideocodecsRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetVideocodecsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetVideocodecsRequest) IsLocked(isLocked bool) TagServiceAPIGetVideocodecsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetVideocodecsRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetVideocodecsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetVideocodecsRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetVideocodecsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetVideocodecsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetVideocodecsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetVideocodecsRequest) Is3D(is3D bool) TagServiceAPIGetVideocodecsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetVideocodecsRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetVideocodecsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetVideocodecsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetVideocodecsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetVideocodecsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetVideocodecsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetVideocodecsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetVideocodecsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetVideocodecsRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetVideocodecsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetVideocodecsRequest) NameLessThan(nameLessThan string) TagServiceAPIGetVideocodecsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetVideocodecsRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetVideocodecsExecute(r)
}

/*
GetVideocodecs Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetVideocodecsRequest
*/
func (a *TagServiceAPIService) GetVideocodecs(ctx context.Context) TagServiceAPIGetVideocodecsRequest {
	return TagServiceAPIGetVideocodecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetVideocodecsExecute(r TagServiceAPIGetVideocodecsRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetVideocodecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/VideoCodecs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIGetYearsRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r TagServiceAPIGetYearsRequest) ArtistType(artistType string) TagServiceAPIGetYearsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetYearsRequest) MaxOfficialRating(maxOfficialRating string) TagServiceAPIGetYearsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r TagServiceAPIGetYearsRequest) HasThemeSong(hasThemeSong bool) TagServiceAPIGetYearsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r TagServiceAPIGetYearsRequest) HasThemeVideo(hasThemeVideo bool) TagServiceAPIGetYearsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r TagServiceAPIGetYearsRequest) HasSubtitles(hasSubtitles bool) TagServiceAPIGetYearsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r TagServiceAPIGetYearsRequest) HasSpecialFeature(hasSpecialFeature bool) TagServiceAPIGetYearsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r TagServiceAPIGetYearsRequest) HasTrailer(hasTrailer bool) TagServiceAPIGetYearsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r TagServiceAPIGetYearsRequest) AdjacentTo(adjacentTo string) TagServiceAPIGetYearsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r TagServiceAPIGetYearsRequest) MinIndexNumber(minIndexNumber int32) TagServiceAPIGetYearsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MinStartDate(minStartDate string) TagServiceAPIGetYearsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MaxStartDate(maxStartDate string) TagServiceAPIGetYearsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MinEndDate(minEndDate string) TagServiceAPIGetYearsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MaxEndDate(maxEndDate string) TagServiceAPIGetYearsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r TagServiceAPIGetYearsRequest) MinPlayers(minPlayers int32) TagServiceAPIGetYearsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r TagServiceAPIGetYearsRequest) MaxPlayers(maxPlayers int32) TagServiceAPIGetYearsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r TagServiceAPIGetYearsRequest) ParentIndexNumber(parentIndexNumber int32) TagServiceAPIGetYearsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r TagServiceAPIGetYearsRequest) HasParentalRating(hasParentalRating bool) TagServiceAPIGetYearsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r TagServiceAPIGetYearsRequest) IsHD(isHD bool) TagServiceAPIGetYearsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r TagServiceAPIGetYearsRequest) IsUnaired(isUnaired bool) TagServiceAPIGetYearsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r TagServiceAPIGetYearsRequest) MinCommunityRating(minCommunityRating float64) TagServiceAPIGetYearsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r TagServiceAPIGetYearsRequest) MinCriticRating(minCriticRating float64) TagServiceAPIGetYearsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r TagServiceAPIGetYearsRequest) AiredDuringSeason(airedDuringSeason int32) TagServiceAPIGetYearsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MinPremiereDate(minPremiereDate string) TagServiceAPIGetYearsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MinDateLastSaved(minDateLastSaved string) TagServiceAPIGetYearsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) TagServiceAPIGetYearsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r TagServiceAPIGetYearsRequest) MaxPremiereDate(maxPremiereDate string) TagServiceAPIGetYearsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r TagServiceAPIGetYearsRequest) HasOverview(hasOverview bool) TagServiceAPIGetYearsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r TagServiceAPIGetYearsRequest) HasImdbId(hasImdbId bool) TagServiceAPIGetYearsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r TagServiceAPIGetYearsRequest) HasTmdbId(hasTmdbId bool) TagServiceAPIGetYearsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r TagServiceAPIGetYearsRequest) HasTvdbId(hasTvdbId bool) TagServiceAPIGetYearsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) ExcludeItemIds(excludeItemIds string) TagServiceAPIGetYearsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r TagServiceAPIGetYearsRequest) StartIndex(startIndex int32) TagServiceAPIGetYearsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r TagServiceAPIGetYearsRequest) Limit(limit int32) TagServiceAPIGetYearsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r TagServiceAPIGetYearsRequest) Recursive(recursive bool) TagServiceAPIGetYearsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r TagServiceAPIGetYearsRequest) SearchTerm(searchTerm string) TagServiceAPIGetYearsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r TagServiceAPIGetYearsRequest) SortOrder(sortOrder string) TagServiceAPIGetYearsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r TagServiceAPIGetYearsRequest) ParentId(parentId string) TagServiceAPIGetYearsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r TagServiceAPIGetYearsRequest) Fields(fields string) TagServiceAPIGetYearsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) ExcludeItemTypes(excludeItemTypes string) TagServiceAPIGetYearsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) IncludeItemTypes(includeItemTypes string) TagServiceAPIGetYearsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r TagServiceAPIGetYearsRequest) AnyProviderIdEquals(anyProviderIdEquals string) TagServiceAPIGetYearsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r TagServiceAPIGetYearsRequest) Filters(filters string) TagServiceAPIGetYearsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r TagServiceAPIGetYearsRequest) IsFavorite(isFavorite bool) TagServiceAPIGetYearsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r TagServiceAPIGetYearsRequest) IsMovie(isMovie bool) TagServiceAPIGetYearsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r TagServiceAPIGetYearsRequest) IsSeries(isSeries bool) TagServiceAPIGetYearsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r TagServiceAPIGetYearsRequest) IsFolder(isFolder bool) TagServiceAPIGetYearsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r TagServiceAPIGetYearsRequest) IsNews(isNews bool) TagServiceAPIGetYearsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r TagServiceAPIGetYearsRequest) IsKids(isKids bool) TagServiceAPIGetYearsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r TagServiceAPIGetYearsRequest) IsSports(isSports bool) TagServiceAPIGetYearsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r TagServiceAPIGetYearsRequest) IsNew(isNew bool) TagServiceAPIGetYearsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r TagServiceAPIGetYearsRequest) IsPremiere(isPremiere bool) TagServiceAPIGetYearsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r TagServiceAPIGetYearsRequest) IsNewOrPremiere(isNewOrPremiere bool) TagServiceAPIGetYearsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r TagServiceAPIGetYearsRequest) IsRepeat(isRepeat bool) TagServiceAPIGetYearsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r TagServiceAPIGetYearsRequest) ProjectToMedia(projectToMedia bool) TagServiceAPIGetYearsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r TagServiceAPIGetYearsRequest) MediaTypes(mediaTypes string) TagServiceAPIGetYearsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r TagServiceAPIGetYearsRequest) ImageTypes(imageTypes string) TagServiceAPIGetYearsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r TagServiceAPIGetYearsRequest) SortBy(sortBy string) TagServiceAPIGetYearsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r TagServiceAPIGetYearsRequest) IsPlayed(isPlayed bool) TagServiceAPIGetYearsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) Genres(genres string) TagServiceAPIGetYearsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) OfficialRatings(officialRatings string) TagServiceAPIGetYearsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) Tags(tags string) TagServiceAPIGetYearsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) ExcludeTags(excludeTags string) TagServiceAPIGetYearsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) Years(years string) TagServiceAPIGetYearsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r TagServiceAPIGetYearsRequest) EnableImages(enableImages bool) TagServiceAPIGetYearsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r TagServiceAPIGetYearsRequest) EnableUserData(enableUserData bool) TagServiceAPIGetYearsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r TagServiceAPIGetYearsRequest) ImageTypeLimit(imageTypeLimit int32) TagServiceAPIGetYearsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r TagServiceAPIGetYearsRequest) EnableImageTypes(enableImageTypes string) TagServiceAPIGetYearsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetYearsRequest) Person(person string) TagServiceAPIGetYearsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r TagServiceAPIGetYearsRequest) PersonIds(personIds string) TagServiceAPIGetYearsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r TagServiceAPIGetYearsRequest) PersonTypes(personTypes string) TagServiceAPIGetYearsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) Studios(studios string) TagServiceAPIGetYearsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) StudioIds(studioIds string) TagServiceAPIGetYearsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) Artists(artists string) TagServiceAPIGetYearsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) ArtistIds(artistIds string) TagServiceAPIGetYearsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r TagServiceAPIGetYearsRequest) Albums(albums string) TagServiceAPIGetYearsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r TagServiceAPIGetYearsRequest) Ids(ids string) TagServiceAPIGetYearsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) VideoTypes(videoTypes string) TagServiceAPIGetYearsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) Containers(containers string) TagServiceAPIGetYearsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) AudioCodecs(audioCodecs string) TagServiceAPIGetYearsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) AudioLayouts(audioLayouts string) TagServiceAPIGetYearsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) VideoCodecs(videoCodecs string) TagServiceAPIGetYearsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) ExtendedVideoTypes(extendedVideoTypes string) TagServiceAPIGetYearsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) SubtitleCodecs(subtitleCodecs string) TagServiceAPIGetYearsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r TagServiceAPIGetYearsRequest) Path(path string) TagServiceAPIGetYearsRequest {
	r.path = &path
	return r
}

// User Id
func (r TagServiceAPIGetYearsRequest) UserId(userId string) TagServiceAPIGetYearsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r TagServiceAPIGetYearsRequest) MinOfficialRating(minOfficialRating string) TagServiceAPIGetYearsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r TagServiceAPIGetYearsRequest) IsLocked(isLocked bool) TagServiceAPIGetYearsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r TagServiceAPIGetYearsRequest) IsPlaceHolder(isPlaceHolder bool) TagServiceAPIGetYearsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r TagServiceAPIGetYearsRequest) HasOfficialRating(hasOfficialRating bool) TagServiceAPIGetYearsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r TagServiceAPIGetYearsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) TagServiceAPIGetYearsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r TagServiceAPIGetYearsRequest) Is3D(is3D bool) TagServiceAPIGetYearsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r TagServiceAPIGetYearsRequest) SeriesStatus(seriesStatus string) TagServiceAPIGetYearsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetYearsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) TagServiceAPIGetYearsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetYearsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) TagServiceAPIGetYearsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r TagServiceAPIGetYearsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) TagServiceAPIGetYearsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r TagServiceAPIGetYearsRequest) NameStartsWith(nameStartsWith string) TagServiceAPIGetYearsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r TagServiceAPIGetYearsRequest) NameLessThan(nameLessThan string) TagServiceAPIGetYearsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r TagServiceAPIGetYearsRequest) Execute() (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetYearsExecute(r)
}

/*
GetYears Gets items based on a query.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TagServiceAPIGetYearsRequest
*/
func (a *TagServiceAPIService) GetYears(ctx context.Context) TagServiceAPIGetYearsRequest {
	return TagServiceAPIGetYearsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetYearsExecute(r TagServiceAPIGetYearsRequest) (*ModelQueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetYears")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Years"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TagServiceAPIPostItemsByIdTagsAddRequest struct {
	ctx context.Context
	ApiService *TagServiceAPIService
	id string
	modelUserLibraryAddTags *ModelUserLibraryAddTags
}

// AddTags
func (r TagServiceAPIPostItemsByIdTagsAddRequest) ModelUserLibraryAddTags(modelUserLibraryAddTags ModelUserLibraryAddTags) TagServiceAPIPostItemsByIdTagsAddRequest {
	r.modelUserLibraryAddTags = &modelUserLibraryAddTags
	return r
}

func (r TagServiceAPIPostItemsByIdTagsAddRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdTagsAddExecute(r)
}

/*
PostItemsByIdTagsAdd Adds new tags to an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return TagServiceAPIPostItemsByIdTagsAddRequest
*/
func (a *TagServiceAPIService) PostItemsByIdTagsAdd(ctx context.Context, id string) TagServiceAPIPostItemsByIdTagsAddRequest {
	return TagServiceAPIPostItemsByIdTagsAddRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TagServiceAPIService) PostItemsByIdTagsAddExecute(r TagServiceAPIPostItemsByIdTagsAddRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.PostItemsByIdTagsAdd")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Tags/Add"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelUserLibraryAddTags == nil {
		return nil, reportError("modelUserLibraryAddTags is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelUserLibraryAddTags
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// LibraryServiceAPIService LibraryServiceAPI service
type LibraryServiceAPIService service

type LibraryServiceAPIDeleteItemsRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	ids *string
}

// Ids
func (r LibraryServiceAPIDeleteItemsRequest) Ids(ids string) LibraryServiceAPIDeleteItemsRequest {
	r.ids = &ids
	return r
}

func (r LibraryServiceAPIDeleteItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemsExecute(r)
}

/*
DeleteItems Deletes an item from the library and file system

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIDeleteItemsRequest
*/
func (a *LibraryServiceAPIService) DeleteItems(ctx context.Context) LibraryServiceAPIDeleteItemsRequest {
	return LibraryServiceAPIDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) DeleteItemsExecute(r LibraryServiceAPIDeleteItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.DeleteItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIDeleteItemsByIdRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
}

func (r LibraryServiceAPIDeleteItemsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemsByIdExecute(r)
}

/*
DeleteItemsById Deletes an item from the library and file system

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIDeleteItemsByIdRequest
*/
func (a *LibraryServiceAPIService) DeleteItemsById(ctx context.Context, id string) LibraryServiceAPIDeleteItemsByIdRequest {
	return LibraryServiceAPIDeleteItemsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) DeleteItemsByIdExecute(r LibraryServiceAPIDeleteItemsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.DeleteItemsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIGetAlbumsByIdSimilarRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) EnableImages(enableImages bool) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) UserId(userId string) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) Limit(limit int32) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) Fields(fields string) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetAlbumsByIdSimilarRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetAlbumsByIdSimilarExecute(r)
}

/*
GetAlbumsByIdSimilar Finds albums similar to a given album.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetAlbumsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetAlbumsByIdSimilar(ctx context.Context, id string) LibraryServiceAPIGetAlbumsByIdSimilarRequest {
	return LibraryServiceAPIGetAlbumsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetAlbumsByIdSimilarExecute(r LibraryServiceAPIGetAlbumsByIdSimilarRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetAlbumsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Albums/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetArtistsByIdSimilarRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) EnableImages(enableImages bool) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) UserId(userId string) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) Limit(limit int32) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) Fields(fields string) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetArtistsByIdSimilarRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetArtistsByIdSimilarExecute(r)
}

/*
GetArtistsByIdSimilar Finds albums similar to a given album.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetArtistsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetArtistsByIdSimilar(ctx context.Context, id string) LibraryServiceAPIGetArtistsByIdSimilarRequest {
	return LibraryServiceAPIGetArtistsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetArtistsByIdSimilarExecute(r LibraryServiceAPIGetArtistsByIdSimilarRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetArtistsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetGamesByIdSimilarRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) EnableImages(enableImages bool) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) UserId(userId string) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) Limit(limit int32) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetGamesByIdSimilarRequest) Fields(fields string) LibraryServiceAPIGetGamesByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetGamesByIdSimilarRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetGamesByIdSimilarExecute(r)
}

/*
GetGamesByIdSimilar Finds games similar to a given game.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetGamesByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetGamesByIdSimilar(ctx context.Context, id string) LibraryServiceAPIGetGamesByIdSimilarRequest {
	return LibraryServiceAPIGetGamesByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetGamesByIdSimilarExecute(r LibraryServiceAPIGetGamesByIdSimilarRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetGamesByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Games/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdAncestorsRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	userId *string
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetItemsByIdAncestorsRequest) UserId(userId string) LibraryServiceAPIGetItemsByIdAncestorsRequest {
	r.userId = &userId
	return r
}

func (r LibraryServiceAPIGetItemsByIdAncestorsRequest) Execute() ([]ModelBaseItemDto, *http.Response, error) {
	return r.ApiService.GetItemsByIdAncestorsExecute(r)
}

/*
GetItemsByIdAncestors Gets all parents of an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdAncestorsRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdAncestors(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdAncestorsRequest {
	return LibraryServiceAPIGetItemsByIdAncestorsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ModelBaseItemDto
func (a *LibraryServiceAPIService) GetItemsByIdAncestorsExecute(r LibraryServiceAPIGetItemsByIdAncestorsRequest) ([]ModelBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdAncestors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Ancestors"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdCriticreviewsRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	startIndex *int32
	limit *int32
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LibraryServiceAPIGetItemsByIdCriticreviewsRequest) StartIndex(startIndex int32) LibraryServiceAPIGetItemsByIdCriticreviewsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetItemsByIdCriticreviewsRequest) Limit(limit int32) LibraryServiceAPIGetItemsByIdCriticreviewsRequest {
	r.limit = &limit
	return r
}

func (r LibraryServiceAPIGetItemsByIdCriticreviewsRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetItemsByIdCriticreviewsExecute(r)
}

/*
GetItemsByIdCriticreviews Gets critic reviews for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdCriticreviewsRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdCriticreviews(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdCriticreviewsRequest {
	return LibraryServiceAPIGetItemsByIdCriticreviewsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetItemsByIdCriticreviewsExecute(r LibraryServiceAPIGetItemsByIdCriticreviewsRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdCriticreviews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/CriticReviews"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdDeleteinfoRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
}

func (r LibraryServiceAPIGetItemsByIdDeleteinfoRequest) Execute() (*ModelLibraryDeleteInfo, *http.Response, error) {
	return r.ApiService.GetItemsByIdDeleteinfoExecute(r)
}

/*
GetItemsByIdDeleteinfo Gets delete info for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdDeleteinfoRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdDeleteinfo(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdDeleteinfoRequest {
	return LibraryServiceAPIGetItemsByIdDeleteinfoRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelLibraryDeleteInfo
func (a *LibraryServiceAPIService) GetItemsByIdDeleteinfoExecute(r LibraryServiceAPIGetItemsByIdDeleteinfoRequest) (*ModelLibraryDeleteInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLibraryDeleteInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdDeleteinfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/DeleteInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdDownloadRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
}

func (r LibraryServiceAPIGetItemsByIdDownloadRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsByIdDownloadExecute(r)
}

/*
GetItemsByIdDownload Downloads item media

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdDownloadRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdDownload(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdDownloadRequest {
	return LibraryServiceAPIGetItemsByIdDownloadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) GetItemsByIdDownloadExecute(r LibraryServiceAPIGetItemsByIdDownloadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdDownload")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Download"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdFileRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
}

func (r LibraryServiceAPIGetItemsByIdFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsByIdFileExecute(r)
}

/*
GetItemsByIdFile Gets the original file of an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdFileRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdFile(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdFileRequest {
	return LibraryServiceAPIGetItemsByIdFileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) GetItemsByIdFileExecute(r LibraryServiceAPIGetItemsByIdFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/File"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdSimilarRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) EnableImages(enableImages bool) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) UserId(userId string) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) Limit(limit int32) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetItemsByIdSimilarRequest) Fields(fields string) LibraryServiceAPIGetItemsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetItemsByIdSimilarRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetItemsByIdSimilarExecute(r)
}

/*
GetItemsByIdSimilar Gets similar items

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdSimilar(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdSimilarRequest {
	return LibraryServiceAPIGetItemsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetItemsByIdSimilarExecute(r LibraryServiceAPIGetItemsByIdSimilarRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdThememediaRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	userId *string
	inheritFromParent *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	enableUserData *bool
	fields *string
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetItemsByIdThememediaRequest) UserId(userId string) LibraryServiceAPIGetItemsByIdThememediaRequest {
	r.userId = &userId
	return r
}

// Determines whether or not parent items should be searched for theme media.
func (r LibraryServiceAPIGetItemsByIdThememediaRequest) InheritFromParent(inheritFromParent bool) LibraryServiceAPIGetItemsByIdThememediaRequest {
	r.inheritFromParent = &inheritFromParent
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetItemsByIdThememediaRequest) EnableImages(enableImages bool) LibraryServiceAPIGetItemsByIdThememediaRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetItemsByIdThememediaRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetItemsByIdThememediaRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetItemsByIdThememediaRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetItemsByIdThememediaRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetItemsByIdThememediaRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetItemsByIdThememediaRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetItemsByIdThememediaRequest) Fields(fields string) LibraryServiceAPIGetItemsByIdThememediaRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetItemsByIdThememediaRequest) Execute() (*ModelAllThemeMediaResult, *http.Response, error) {
	return r.ApiService.GetItemsByIdThememediaExecute(r)
}

/*
GetItemsByIdThememedia Gets theme videos and songs for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdThememediaRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdThememedia(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdThememediaRequest {
	return LibraryServiceAPIGetItemsByIdThememediaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelAllThemeMediaResult
func (a *LibraryServiceAPIService) GetItemsByIdThememediaExecute(r LibraryServiceAPIGetItemsByIdThememediaRequest) (*ModelAllThemeMediaResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelAllThemeMediaResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdThememedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/ThemeMedia"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.inheritFromParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InheritFromParent", r.inheritFromParent, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdThemesongsRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	userId *string
	inheritFromParent *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	enableUserData *bool
	fields *string
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) UserId(userId string) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	r.userId = &userId
	return r
}

// Determines whether or not parent items should be searched for theme media.
func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) InheritFromParent(inheritFromParent bool) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	r.inheritFromParent = &inheritFromParent
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) EnableImages(enableImages bool) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) Fields(fields string) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetItemsByIdThemesongsRequest) Execute() (*ModelThemeMediaResult, *http.Response, error) {
	return r.ApiService.GetItemsByIdThemesongsExecute(r)
}

/*
GetItemsByIdThemesongs Gets theme songs for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdThemesongsRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdThemesongs(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdThemesongsRequest {
	return LibraryServiceAPIGetItemsByIdThemesongsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelThemeMediaResult
func (a *LibraryServiceAPIService) GetItemsByIdThemesongsExecute(r LibraryServiceAPIGetItemsByIdThemesongsRequest) (*ModelThemeMediaResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelThemeMediaResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdThemesongs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/ThemeSongs"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.inheritFromParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InheritFromParent", r.inheritFromParent, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsByIdThemevideosRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	userId *string
	inheritFromParent *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	enableUserData *bool
	fields *string
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) UserId(userId string) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	r.userId = &userId
	return r
}

// Determines whether or not parent items should be searched for theme media.
func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) InheritFromParent(inheritFromParent bool) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	r.inheritFromParent = &inheritFromParent
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) EnableImages(enableImages bool) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) Fields(fields string) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetItemsByIdThemevideosRequest) Execute() (*ModelThemeMediaResult, *http.Response, error) {
	return r.ApiService.GetItemsByIdThemevideosExecute(r)
}

/*
GetItemsByIdThemevideos Gets theme videos for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetItemsByIdThemevideosRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdThemevideos(ctx context.Context, id string) LibraryServiceAPIGetItemsByIdThemevideosRequest {
	return LibraryServiceAPIGetItemsByIdThemevideosRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelThemeMediaResult
func (a *LibraryServiceAPIService) GetItemsByIdThemevideosExecute(r LibraryServiceAPIGetItemsByIdThemevideosRequest) (*ModelThemeMediaResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelThemeMediaResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdThemevideos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/ThemeVideos"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.inheritFromParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InheritFromParent", r.inheritFromParent, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsCountsRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	userId *string
	isFavorite *bool
}

// Optional. Get counts from a specific user&#39;s library.
func (r LibraryServiceAPIGetItemsCountsRequest) UserId(userId string) LibraryServiceAPIGetItemsCountsRequest {
	r.userId = &userId
	return r
}

// Optional. Get counts of favorite items
func (r LibraryServiceAPIGetItemsCountsRequest) IsFavorite(isFavorite bool) LibraryServiceAPIGetItemsCountsRequest {
	r.isFavorite = &isFavorite
	return r
}

func (r LibraryServiceAPIGetItemsCountsRequest) Execute() (*ModelItemCounts, *http.Response, error) {
	return r.ApiService.GetItemsCountsExecute(r)
}

/*
GetItemsCounts Method for GetItemsCounts

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIGetItemsCountsRequest
*/
func (a *LibraryServiceAPIService) GetItemsCounts(ctx context.Context) LibraryServiceAPIGetItemsCountsRequest {
	return LibraryServiceAPIGetItemsCountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelItemCounts
func (a *LibraryServiceAPIService) GetItemsCountsExecute(r LibraryServiceAPIGetItemsCountsRequest) (*ModelItemCounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelItemCounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsCounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/Counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetItemsIntrosRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIGetItemsIntrosRequest) Execute() ([]ModelPersistenceIntroDebugInfo, *http.Response, error) {
	return r.ApiService.GetItemsIntrosExecute(r)
}

/*
GetItemsIntros Gets info to debug intros

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIGetItemsIntrosRequest
*/
func (a *LibraryServiceAPIService) GetItemsIntros(ctx context.Context) LibraryServiceAPIGetItemsIntrosRequest {
	return LibraryServiceAPIGetItemsIntrosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelPersistenceIntroDebugInfo
func (a *LibraryServiceAPIService) GetItemsIntrosExecute(r LibraryServiceAPIGetItemsIntrosRequest) ([]ModelPersistenceIntroDebugInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelPersistenceIntroDebugInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsIntros")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/Intros"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetLibrariesAvailableoptionsRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIGetLibrariesAvailableoptionsRequest) Execute() (*ModelLibraryLibraryOptionsResult, *http.Response, error) {
	return r.ApiService.GetLibrariesAvailableoptionsExecute(r)
}

/*
GetLibrariesAvailableoptions Method for GetLibrariesAvailableoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIGetLibrariesAvailableoptionsRequest
*/
func (a *LibraryServiceAPIService) GetLibrariesAvailableoptions(ctx context.Context) LibraryServiceAPIGetLibrariesAvailableoptionsRequest {
	return LibraryServiceAPIGetLibrariesAvailableoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLibraryLibraryOptionsResult
func (a *LibraryServiceAPIService) GetLibrariesAvailableoptionsExecute(r LibraryServiceAPIGetLibrariesAvailableoptionsRequest) (*ModelLibraryLibraryOptionsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLibraryLibraryOptionsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibrariesAvailableoptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Libraries/AvailableOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetLibraryMediafoldersRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	isHidden *bool
}

// Optional. Filter by folders that are marked hidden, or not.
func (r LibraryServiceAPIGetLibraryMediafoldersRequest) IsHidden(isHidden bool) LibraryServiceAPIGetLibraryMediafoldersRequest {
	r.isHidden = &isHidden
	return r
}

func (r LibraryServiceAPIGetLibraryMediafoldersRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLibraryMediafoldersExecute(r)
}

/*
GetLibraryMediafolders Gets all user media folders.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIGetLibraryMediafoldersRequest
*/
func (a *LibraryServiceAPIService) GetLibraryMediafolders(ctx context.Context) LibraryServiceAPIGetLibraryMediafoldersRequest {
	return LibraryServiceAPIGetLibraryMediafoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetLibraryMediafoldersExecute(r LibraryServiceAPIGetLibraryMediafoldersRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibraryMediafolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/MediaFolders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isHidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHidden", r.isHidden, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetLibraryPhysicalpathsRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIGetLibraryPhysicalpathsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetLibraryPhysicalpathsExecute(r)
}

/*
GetLibraryPhysicalpaths Gets a list of physical paths from virtual folders

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIGetLibraryPhysicalpathsRequest
*/
func (a *LibraryServiceAPIService) GetLibraryPhysicalpaths(ctx context.Context) LibraryServiceAPIGetLibraryPhysicalpathsRequest {
	return LibraryServiceAPIGetLibraryPhysicalpathsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *LibraryServiceAPIService) GetLibraryPhysicalpathsExecute(r LibraryServiceAPIGetLibraryPhysicalpathsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibraryPhysicalpaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/PhysicalPaths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetLibrarySelectablemediafoldersRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIGetLibrarySelectablemediafoldersRequest) Execute() ([]ModelLibraryMediaFolder, *http.Response, error) {
	return r.ApiService.GetLibrarySelectablemediafoldersExecute(r)
}

/*
GetLibrarySelectablemediafolders Gets all user media folders.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIGetLibrarySelectablemediafoldersRequest
*/
func (a *LibraryServiceAPIService) GetLibrarySelectablemediafolders(ctx context.Context) LibraryServiceAPIGetLibrarySelectablemediafoldersRequest {
	return LibraryServiceAPIGetLibrarySelectablemediafoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelLibraryMediaFolder
func (a *LibraryServiceAPIService) GetLibrarySelectablemediafoldersExecute(r LibraryServiceAPIGetLibrarySelectablemediafoldersRequest) ([]ModelLibraryMediaFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelLibraryMediaFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibrarySelectablemediafolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/SelectableMediaFolders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetMoviesByIdSimilarRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) EnableImages(enableImages bool) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) UserId(userId string) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) Limit(limit int32) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) Fields(fields string) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetMoviesByIdSimilarRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetMoviesByIdSimilarExecute(r)
}

/*
GetMoviesByIdSimilar Finds movies and trailers similar to a given movie.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetMoviesByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetMoviesByIdSimilar(ctx context.Context, id string) LibraryServiceAPIGetMoviesByIdSimilarRequest {
	return LibraryServiceAPIGetMoviesByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetMoviesByIdSimilarExecute(r LibraryServiceAPIGetMoviesByIdSimilarRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetMoviesByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Movies/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetShowsByIdSimilarRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) EnableImages(enableImages bool) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) UserId(userId string) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) Limit(limit int32) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetShowsByIdSimilarRequest) Fields(fields string) LibraryServiceAPIGetShowsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetShowsByIdSimilarRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetShowsByIdSimilarExecute(r)
}

/*
GetShowsByIdSimilar Finds tv shows similar to a given one.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetShowsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetShowsByIdSimilar(ctx context.Context, id string) LibraryServiceAPIGetShowsByIdSimilarRequest {
	return LibraryServiceAPIGetShowsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetShowsByIdSimilarExecute(r LibraryServiceAPIGetShowsByIdSimilarRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetShowsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Shows/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIGetTrailersByIdSimilarRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) EnableImages(enableImages bool) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) EnableUserData(enableUserData bool) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) EnableImageTypes(enableImageTypes string) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) UserId(userId string) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) Limit(limit int32) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) Fields(fields string) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r LibraryServiceAPIGetTrailersByIdSimilarRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetTrailersByIdSimilarExecute(r)
}

/*
GetTrailersByIdSimilar Finds movies and trailers similar to a given trailer.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIGetTrailersByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetTrailersByIdSimilar(ctx context.Context, id string) LibraryServiceAPIGetTrailersByIdSimilarRequest {
	return LibraryServiceAPIGetTrailersByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetTrailersByIdSimilarExecute(r LibraryServiceAPIGetTrailersByIdSimilarRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetTrailersByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Trailers/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LibraryServiceAPIPostItemsByIdDeleteRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	id string
}

func (r LibraryServiceAPIPostItemsByIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdDeleteExecute(r)
}

/*
PostItemsByIdDelete Deletes an item from the library and file system

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return LibraryServiceAPIPostItemsByIdDeleteRequest
*/
func (a *LibraryServiceAPIService) PostItemsByIdDelete(ctx context.Context, id string) LibraryServiceAPIPostItemsByIdDeleteRequest {
	return LibraryServiceAPIPostItemsByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostItemsByIdDeleteExecute(r LibraryServiceAPIPostItemsByIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostItemsByIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIPostItemsDeleteRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	ids *string
}

// Ids
func (r LibraryServiceAPIPostItemsDeleteRequest) Ids(ids string) LibraryServiceAPIPostItemsDeleteRequest {
	r.ids = &ids
	return r
}

func (r LibraryServiceAPIPostItemsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsDeleteExecute(r)
}

/*
PostItemsDelete Deletes an item from the library and file system

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIPostItemsDeleteRequest
*/
func (a *LibraryServiceAPIService) PostItemsDelete(ctx context.Context) LibraryServiceAPIPostItemsDeleteRequest {
	return LibraryServiceAPIPostItemsDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostItemsDeleteExecute(r LibraryServiceAPIPostItemsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostItemsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/Delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIPostLibraryMediaUpdatedRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
	modelLibraryPostUpdatedMedia *ModelLibraryPostUpdatedMedia
}

// PostUpdatedMedia
func (r LibraryServiceAPIPostLibraryMediaUpdatedRequest) ModelLibraryPostUpdatedMedia(modelLibraryPostUpdatedMedia ModelLibraryPostUpdatedMedia) LibraryServiceAPIPostLibraryMediaUpdatedRequest {
	r.modelLibraryPostUpdatedMedia = &modelLibraryPostUpdatedMedia
	return r
}

func (r LibraryServiceAPIPostLibraryMediaUpdatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryMediaUpdatedExecute(r)
}

/*
PostLibraryMediaUpdated Reports that new movies have been added by an external source

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIPostLibraryMediaUpdatedRequest
*/
func (a *LibraryServiceAPIService) PostLibraryMediaUpdated(ctx context.Context) LibraryServiceAPIPostLibraryMediaUpdatedRequest {
	return LibraryServiceAPIPostLibraryMediaUpdatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryMediaUpdatedExecute(r LibraryServiceAPIPostLibraryMediaUpdatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryMediaUpdated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Media/Updated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLibraryPostUpdatedMedia == nil {
		return nil, reportError("modelLibraryPostUpdatedMedia is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLibraryPostUpdatedMedia
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIPostLibraryMoviesAddedRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIPostLibraryMoviesAddedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryMoviesAddedExecute(r)
}

/*
PostLibraryMoviesAdded Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIPostLibraryMoviesAddedRequest
*/
func (a *LibraryServiceAPIService) PostLibraryMoviesAdded(ctx context.Context) LibraryServiceAPIPostLibraryMoviesAddedRequest {
	return LibraryServiceAPIPostLibraryMoviesAddedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryMoviesAddedExecute(r LibraryServiceAPIPostLibraryMoviesAddedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryMoviesAdded")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Movies/Added"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIPostLibraryMoviesUpdatedRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIPostLibraryMoviesUpdatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryMoviesUpdatedExecute(r)
}

/*
PostLibraryMoviesUpdated Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIPostLibraryMoviesUpdatedRequest
*/
func (a *LibraryServiceAPIService) PostLibraryMoviesUpdated(ctx context.Context) LibraryServiceAPIPostLibraryMoviesUpdatedRequest {
	return LibraryServiceAPIPostLibraryMoviesUpdatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryMoviesUpdatedExecute(r LibraryServiceAPIPostLibraryMoviesUpdatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryMoviesUpdated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Movies/Updated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIPostLibraryRefreshRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIPostLibraryRefreshRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryRefreshExecute(r)
}

/*
PostLibraryRefresh Starts a library scan

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIPostLibraryRefreshRequest
*/
func (a *LibraryServiceAPIService) PostLibraryRefresh(ctx context.Context) LibraryServiceAPIPostLibraryRefreshRequest {
	return LibraryServiceAPIPostLibraryRefreshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryRefreshExecute(r LibraryServiceAPIPostLibraryRefreshRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryRefresh")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIPostLibrarySeriesAddedRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIPostLibrarySeriesAddedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibrarySeriesAddedExecute(r)
}

/*
PostLibrarySeriesAdded Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIPostLibrarySeriesAddedRequest
*/
func (a *LibraryServiceAPIService) PostLibrarySeriesAdded(ctx context.Context) LibraryServiceAPIPostLibrarySeriesAddedRequest {
	return LibraryServiceAPIPostLibrarySeriesAddedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibrarySeriesAddedExecute(r LibraryServiceAPIPostLibrarySeriesAddedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibrarySeriesAdded")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Series/Added"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LibraryServiceAPIPostLibrarySeriesUpdatedRequest struct {
	ctx context.Context
	ApiService *LibraryServiceAPIService
}

func (r LibraryServiceAPIPostLibrarySeriesUpdatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibrarySeriesUpdatedExecute(r)
}

/*
PostLibrarySeriesUpdated Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LibraryServiceAPIPostLibrarySeriesUpdatedRequest
*/
func (a *LibraryServiceAPIService) PostLibrarySeriesUpdated(ctx context.Context) LibraryServiceAPIPostLibrarySeriesUpdatedRequest {
	return LibraryServiceAPIPostLibrarySeriesUpdatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibrarySeriesUpdatedExecute(r LibraryServiceAPIPostLibrarySeriesUpdatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibrarySeriesUpdated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Series/Updated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"encoding/json"
	"fmt"
)

// ModelTranscodeReason the model 'ModelTranscodeReason'
type ModelTranscodeReason string

// List of TranscodeReason
const (
	MODELTRANSCODEREASON_CONTAINER_NOT_SUPPORTED ModelTranscodeReason = "ContainerNotSupported"
	MODELTRANSCODEREASON_VIDEO_CODEC_NOT_SUPPORTED ModelTranscodeReason = "VideoCodecNotSupported"
	MODELTRANSCODEREASON_AUDIO_CODEC_NOT_SUPPORTED ModelTranscodeReason = "AudioCodecNotSupported"
	MODELTRANSCODEREASON_CONTAINER_BITRATE_EXCEEDS_LIMIT ModelTranscodeReason = "ContainerBitrateExceedsLimit"
	MODELTRANSCODEREASON_AUDIO_BITRATE_NOT_SUPPORTED ModelTranscodeReason = "AudioBitrateNotSupported"
	MODELTRANSCODEREASON_AUDIO_CHANNELS_NOT_SUPPORTED ModelTranscodeReason = "AudioChannelsNotSupported"
	MODELTRANSCODEREASON_VIDEO_RESOLUTION_NOT_SUPPORTED ModelTranscodeReason = "VideoResolutionNotSupported"
	MODELTRANSCODEREASON_UNKNOWN_VIDEO_STREAM_INFO ModelTranscodeReason = "UnknownVideoStreamInfo"
	MODELTRANSCODEREASON_UNKNOWN_AUDIO_STREAM_INFO ModelTranscodeReason = "UnknownAudioStreamInfo"
	MODELTRANSCODEREASON_AUDIO_PROFILE_NOT_SUPPORTED ModelTranscodeReason = "AudioProfileNotSupported"
	MODELTRANSCODEREASON_AUDIO_SAMPLE_RATE_NOT_SUPPORTED ModelTranscodeReason = "AudioSampleRateNotSupported"
	MODELTRANSCODEREASON_ANAMORPHIC_VIDEO_NOT_SUPPORTED ModelTranscodeReason = "AnamorphicVideoNotSupported"
	MODELTRANSCODEREASON_INTERLACED_VIDEO_NOT_SUPPORTED ModelTranscodeReason = "InterlacedVideoNotSupported"
	MODELTRANSCODEREASON_SECONDARY_AUDIO_NOT_SUPPORTED ModelTranscodeReason = "SecondaryAudioNotSupported"
	MODELTRANSCODEREASON_REF_FRAMES_NOT_SUPPORTED ModelTranscodeReason = "RefFramesNotSupported"
	MODELTRANSCODEREASON_VIDEO_BIT_DEPTH_NOT_SUPPORTED ModelTranscodeReason = "VideoBitDepthNotSupported"
	MODELTRANSCODEREASON_VIDEO_BITRATE_NOT_SUPPORTED ModelTranscodeReason = "VideoBitrateNotSupported"
	MODELTRANSCODEREASON_VIDEO_FRAMERATE_NOT_SUPPORTED ModelTranscodeReason = "VideoFramerateNotSupported"
	MODELTRANSCODEREASON_VIDEO_LEVEL_NOT_SUPPORTED ModelTranscodeReason = "VideoLevelNotSupported"
	MODELTRANSCODEREASON_VIDEO_PROFILE_NOT_SUPPORTED ModelTranscodeReason = "VideoProfileNotSupported"
	MODELTRANSCODEREASON_AUDIO_BIT_DEPTH_NOT_SUPPORTED ModelTranscodeReason = "AudioBitDepthNotSupported"
	MODELTRANSCODEREASON_SUBTITLE_CODEC_NOT_SUPPORTED ModelTranscodeReason = "SubtitleCodecNotSupported"
	MODELTRANSCODEREASON_DIRECT_PLAY_ERROR ModelTranscodeReason = "DirectPlayError"
	MODELTRANSCODEREASON_VIDEO_RANGE_NOT_SUPPORTED ModelTranscodeReason = "VideoRangeNotSupported"
	MODELTRANSCODEREASON_SUBTITLE_CONTENT_OPTIONS_ENABLED ModelTranscodeReason = "SubtitleContentOptionsEnabled"
)

// All allowed values of ModelTranscodeReason enum
var AllowedModelTranscodeReasonEnumValues = []ModelTranscodeReason{
	"ContainerNotSupported",
	"VideoCodecNotSupported",
	"AudioCodecNotSupported",
	"ContainerBitrateExceedsLimit",
	"AudioBitrateNotSupported",
	"AudioChannelsNotSupported",
	"VideoResolutionNotSupported",
	"UnknownVideoStreamInfo",
	"UnknownAudioStreamInfo",
	"AudioProfileNotSupported",
	"AudioSampleRateNotSupported",
	"AnamorphicVideoNotSupported",
	"InterlacedVideoNotSupported",
	"SecondaryAudioNotSupported",
	"RefFramesNotSupported",
	"VideoBitDepthNotSupported",
	"VideoBitrateNotSupported",
	"VideoFramerateNotSupported",
	"VideoLevelNotSupported",
	"VideoProfileNotSupported",
	"AudioBitDepthNotSupported",
	"SubtitleCodecNotSupported",
	"DirectPlayError",
	"VideoRangeNotSupported",
	"SubtitleContentOptionsEnabled",
}

func (v *ModelTranscodeReason) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ModelTranscodeReason(value)
	for _, existing := range AllowedModelTranscodeReasonEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ModelTranscodeReason", value)
}

// NewModelTranscodeReasonFromValue returns a pointer to a valid ModelTranscodeReason
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewModelTranscodeReasonFromValue(v string) (*ModelTranscodeReason, error) {
	ev := ModelTranscodeReason(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ModelTranscodeReason: valid values are %v", v, AllowedModelTranscodeReasonEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ModelTranscodeReason) IsValid() bool {
	for _, existing := range AllowedModelTranscodeReasonEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to TranscodeReason value
func (v ModelTranscodeReason) Ptr() *ModelTranscodeReason {
	return &v
}

type NullableModelTranscodeReason struct {
	value *ModelTranscodeReason
	isSet bool
}

func (v NullableModelTranscodeReason) Get() *ModelTranscodeReason {
	return v.value
}

func (v *NullableModelTranscodeReason) Set(val *ModelTranscodeReason) {
	v.value = val
	v.isSet = true
}

func (v NullableModelTranscodeReason) IsSet() bool {
	return v.isSet
}

func (v *NullableModelTranscodeReason) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableModelTranscodeReason(val *ModelTranscodeReason) *NullableModelTranscodeReason {
	return &NullableModelTranscodeReason{value: val, isSet: true}
}

func (v NullableModelTranscodeReason) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableModelTranscodeReason) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


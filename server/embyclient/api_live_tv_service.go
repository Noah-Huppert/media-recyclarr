/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// LiveTvServiceAPIService LiveTvServiceAPI service
type LiveTvServiceAPIService service

type LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest) ProviderId(providerId string) LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvChannelmappingoptionsExecute(r)
}

/*
DeleteLivetvChannelmappingoptions Method for DeleteLivetvChannelmappingoptions

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappingoptions(ctx context.Context) LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest {
	return LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappingoptionsExecute(r LiveTvServiceAPIDeleteLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIDeleteLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIDeleteLivetvChannelmappingsRequest) ProviderId(providerId string) LiveTvServiceAPIDeleteLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIDeleteLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvChannelmappingsExecute(r)
}

/*
DeleteLivetvChannelmappings Method for DeleteLivetvChannelmappings

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIDeleteLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappings(ctx context.Context) LiveTvServiceAPIDeleteLivetvChannelmappingsRequest {
	return LiveTvServiceAPIDeleteLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappingsExecute(r LiveTvServiceAPIDeleteLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIDeleteLivetvListingprovidersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id *string
}

// Provider id
func (r LiveTvServiceAPIDeleteLivetvListingprovidersRequest) Id(id string) LiveTvServiceAPIDeleteLivetvListingprovidersRequest {
	r.id = &id
	return r
}

func (r LiveTvServiceAPIDeleteLivetvListingprovidersRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvListingprovidersExecute(r)
}

/*
DeleteLivetvListingproviders Deletes a listing provider

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIDeleteLivetvListingprovidersRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvListingproviders(ctx context.Context) LiveTvServiceAPIDeleteLivetvListingprovidersRequest {
	return LiveTvServiceAPIDeleteLivetvListingprovidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvListingprovidersExecute(r LiveTvServiceAPIDeleteLivetvListingprovidersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvListingproviders")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIDeleteLivetvRecordingsByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIDeleteLivetvRecordingsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvRecordingsByIdExecute(r)
}

/*
DeleteLivetvRecordingsById Deletes a live tv recording

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Recording Id
 @return LiveTvServiceAPIDeleteLivetvRecordingsByIdRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvRecordingsById(ctx context.Context, id string) LiveTvServiceAPIDeleteLivetvRecordingsByIdRequest {
	return LiveTvServiceAPIDeleteLivetvRecordingsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvRecordingsByIdExecute(r LiveTvServiceAPIDeleteLivetvRecordingsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvRecordingsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIDeleteLivetvSeriestimersByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIDeleteLivetvSeriestimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvSeriestimersByIdExecute(r)
}

/*
DeleteLivetvSeriestimersById Cancels a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return LiveTvServiceAPIDeleteLivetvSeriestimersByIdRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvSeriestimersById(ctx context.Context, id string) LiveTvServiceAPIDeleteLivetvSeriestimersByIdRequest {
	return LiveTvServiceAPIDeleteLivetvSeriestimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvSeriestimersByIdExecute(r LiveTvServiceAPIDeleteLivetvSeriestimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvSeriestimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIDeleteLivetvTimersByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIDeleteLivetvTimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvTimersByIdExecute(r)
}

/*
DeleteLivetvTimersById Cancels a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return LiveTvServiceAPIDeleteLivetvTimersByIdRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvTimersById(ctx context.Context, id string) LiveTvServiceAPIDeleteLivetvTimersByIdRequest {
	return LiveTvServiceAPIDeleteLivetvTimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvTimersByIdExecute(r LiveTvServiceAPIDeleteLivetvTimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvTimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIDeleteLivetvTunerhostsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id *string
}

// Tuner host id
func (r LiveTvServiceAPIDeleteLivetvTunerhostsRequest) Id(id string) LiveTvServiceAPIDeleteLivetvTunerhostsRequest {
	r.id = &id
	return r
}

func (r LiveTvServiceAPIDeleteLivetvTunerhostsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvTunerhostsExecute(r)
}

/*
DeleteLivetvTunerhosts Deletes a tuner host

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIDeleteLivetvTunerhostsRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvTunerhosts(ctx context.Context) LiveTvServiceAPIDeleteLivetvTunerhostsRequest {
	return LiveTvServiceAPIDeleteLivetvTunerhostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvTunerhostsExecute(r LiveTvServiceAPIDeleteLivetvTunerhostsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvTunerhosts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvAvailablerecordingoptionsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvAvailablerecordingoptionsRequest) Execute() (*ModelLiveTVApiAvailableRecordingOptions, *http.Response, error) {
	return r.ApiService.GetLivetvAvailablerecordingoptionsExecute(r)
}

/*
GetLivetvAvailablerecordingoptions Gets available recording options

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvAvailablerecordingoptionsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvAvailablerecordingoptions(ctx context.Context) LiveTvServiceAPIGetLivetvAvailablerecordingoptionsRequest {
	return LiveTvServiceAPIGetLivetvAvailablerecordingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLiveTVApiAvailableRecordingOptions
func (a *LiveTvServiceAPIService) GetLivetvAvailablerecordingoptionsExecute(r LiveTvServiceAPIGetLivetvAvailablerecordingoptionsRequest) (*ModelLiveTVApiAvailableRecordingOptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTVApiAvailableRecordingOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvAvailablerecordingoptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/AvailableRecordingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest) ProviderId(providerId string) LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvChannelmappingoptionsExecute(r)
}

/*
GetLivetvChannelmappingoptions Method for GetLivetvChannelmappingoptions

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannelmappingoptions(ctx context.Context) LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest {
	return LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvChannelmappingoptionsExecute(r LiveTvServiceAPIGetLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIGetLivetvChannelmappingsRequest) ProviderId(providerId string) LiveTvServiceAPIGetLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIGetLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvChannelmappingsExecute(r)
}

/*
GetLivetvChannelmappings Method for GetLivetvChannelmappings

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannelmappings(ctx context.Context) LiveTvServiceAPIGetLivetvChannelmappingsRequest {
	return LiveTvServiceAPIGetLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvChannelmappingsExecute(r LiveTvServiceAPIGetLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvChannelsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	type_ *ModelLiveTvChannelType
	isLiked *bool
	isDisliked *bool
	enableFavoriteSorting *bool
	addCurrentProgram *bool
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Optional filter by channel type.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Type_(type_ ModelLiveTvChannelType) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.type_ = &type_
	return r
}

// Filter by channels that are liked, or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsLiked(isLiked bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isLiked = &isLiked
	return r
}

// Filter by channels that are disliked, or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsDisliked(isDisliked bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isDisliked = &isDisliked
	return r
}

// Incorporate favorite and like status into channel sorting.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) EnableFavoriteSorting(enableFavoriteSorting bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.enableFavoriteSorting = &enableFavoriteSorting
	return r
}

// Optional. Adds current program info to each channel
func (r LiveTvServiceAPIGetLivetvChannelsRequest) AddCurrentProgram(addCurrentProgram bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.addCurrentProgram = &addCurrentProgram
	return r
}

// Artist or AlbumArtist
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ArtistType(artistType string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MaxOfficialRating(maxOfficialRating string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasThemeSong(hasThemeSong bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasThemeVideo(hasThemeVideo bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasSubtitles(hasSubtitles bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasSpecialFeature(hasSpecialFeature bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasTrailer(hasTrailer bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) AdjacentTo(adjacentTo string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinIndexNumber(minIndexNumber int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinStartDate(minStartDate string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MaxStartDate(maxStartDate string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinEndDate(minEndDate string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MaxEndDate(maxEndDate string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinPlayers(minPlayers int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MaxPlayers(maxPlayers int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ParentIndexNumber(parentIndexNumber int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasParentalRating(hasParentalRating bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsHD(isHD bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsUnaired(isUnaired bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinCommunityRating(minCommunityRating float64) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinCriticRating(minCriticRating float64) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) AiredDuringSeason(airedDuringSeason int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinPremiereDate(minPremiereDate string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinDateLastSaved(minDateLastSaved string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MaxPremiereDate(maxPremiereDate string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasOverview(hasOverview bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasImdbId(hasImdbId bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasTmdbId(hasTmdbId bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasTvdbId(hasTvdbId bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ExcludeItemIds(excludeItemIds string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Recursive(recursive bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r LiveTvServiceAPIGetLivetvChannelsRequest) SearchTerm(searchTerm string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIGetLivetvChannelsRequest) SortOrder(sortOrder string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ParentId(parentId string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Fields(fields string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ExcludeItemTypes(excludeItemTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IncludeItemTypes(includeItemTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) AnyProviderIdEquals(anyProviderIdEquals string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Filters(filters string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsFavorite(isFavorite bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsMovie(isMovie bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsSeries(isSeries bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsFolder(isFolder bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsNews(isNews bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsKids(isKids bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsSports(isSports bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsNew(isNew bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsPremiere(isPremiere bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsNewOrPremiere(isNewOrPremiere bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsRepeat(isRepeat bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ProjectToMedia(projectToMedia bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MediaTypes(mediaTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ImageTypes(imageTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r LiveTvServiceAPIGetLivetvChannelsRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsPlayed(isPlayed bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Genres(genres string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) OfficialRatings(officialRatings string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Tags(tags string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ExcludeTags(excludeTags string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Years(years string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvChannelsRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvChannelsRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Person(person string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) PersonIds(personIds string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r LiveTvServiceAPIGetLivetvChannelsRequest) PersonTypes(personTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Studios(studios string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) StudioIds(studioIds string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Artists(artists string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ArtistIds(artistIds string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Albums(albums string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Ids(ids string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) VideoTypes(videoTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Containers(containers string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) AudioCodecs(audioCodecs string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) AudioLayouts(audioLayouts string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) VideoCodecs(videoCodecs string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ExtendedVideoTypes(extendedVideoTypes string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) SubtitleCodecs(subtitleCodecs string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Path(path string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.path = &path
	return r
}

// User Id
func (r LiveTvServiceAPIGetLivetvChannelsRequest) UserId(userId string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvChannelsRequest) MinOfficialRating(minOfficialRating string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsLocked(isLocked bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r LiveTvServiceAPIGetLivetvChannelsRequest) IsPlaceHolder(isPlaceHolder bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r LiveTvServiceAPIGetLivetvChannelsRequest) HasOfficialRating(hasOfficialRating bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) Is3D(is3D bool) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) SeriesStatus(seriesStatus string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) NameStartsWith(nameStartsWith string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r LiveTvServiceAPIGetLivetvChannelsRequest) NameLessThan(nameLessThan string) LiveTvServiceAPIGetLivetvChannelsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r LiveTvServiceAPIGetLivetvChannelsRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvChannelsExecute(r)
}

/*
GetLivetvChannels Gets available live tv channels.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvChannelsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannels(ctx context.Context) LiveTvServiceAPIGetLivetvChannelsRequest {
	return LiveTvServiceAPIGetLivetvChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvChannelsExecute(r LiveTvServiceAPIGetLivetvChannelsRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Type", r.type_, "")
	}
	if r.isLiked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLiked", r.isLiked, "")
	}
	if r.isDisliked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsDisliked", r.isDisliked, "")
	}
	if r.enableFavoriteSorting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableFavoriteSorting", r.enableFavoriteSorting, "")
	}
	if r.addCurrentProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AddCurrentProgram", r.addCurrentProgram, "")
	}
	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvChannelsByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
	userId *string
}

// Optional attach user data.
func (r LiveTvServiceAPIGetLivetvChannelsByIdRequest) UserId(userId string) LiveTvServiceAPIGetLivetvChannelsByIdRequest {
	r.userId = &userId
	return r
}

func (r LiveTvServiceAPIGetLivetvChannelsByIdRequest) Execute() (*ModelBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvChannelsByIdExecute(r)
}

/*
GetLivetvChannelsById Gets a live tv channel

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Channel Id
 @return LiveTvServiceAPIGetLivetvChannelsByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannelsById(ctx context.Context, id string) LiveTvServiceAPIGetLivetvChannelsByIdRequest {
	return LiveTvServiceAPIGetLivetvChannelsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvChannelsByIdExecute(r LiveTvServiceAPIGetLivetvChannelsByIdRequest) (*ModelBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannelsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvChanneltagsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ArtistType(artistType string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MaxOfficialRating(maxOfficialRating string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasThemeSong(hasThemeSong bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasThemeVideo(hasThemeVideo bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasSubtitles(hasSubtitles bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasSpecialFeature(hasSpecialFeature bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasTrailer(hasTrailer bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) AdjacentTo(adjacentTo string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinIndexNumber(minIndexNumber int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinStartDate(minStartDate string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MaxStartDate(maxStartDate string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinEndDate(minEndDate string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MaxEndDate(maxEndDate string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinPlayers(minPlayers int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MaxPlayers(maxPlayers int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ParentIndexNumber(parentIndexNumber int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasParentalRating(hasParentalRating bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsHD(isHD bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsUnaired(isUnaired bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinCommunityRating(minCommunityRating float64) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinCriticRating(minCriticRating float64) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) AiredDuringSeason(airedDuringSeason int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinPremiereDate(minPremiereDate string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinDateLastSaved(minDateLastSaved string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MaxPremiereDate(maxPremiereDate string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasOverview(hasOverview bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasImdbId(hasImdbId bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasTmdbId(hasTmdbId bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasTvdbId(hasTvdbId bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ExcludeItemIds(excludeItemIds string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Recursive(recursive bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) SearchTerm(searchTerm string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) SortOrder(sortOrder string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ParentId(parentId string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Fields(fields string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ExcludeItemTypes(excludeItemTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IncludeItemTypes(includeItemTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) AnyProviderIdEquals(anyProviderIdEquals string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Filters(filters string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsFavorite(isFavorite bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsMovie(isMovie bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsSeries(isSeries bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsFolder(isFolder bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsNews(isNews bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsKids(isKids bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsSports(isSports bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsNew(isNew bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsPremiere(isPremiere bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsNewOrPremiere(isNewOrPremiere bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsRepeat(isRepeat bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ProjectToMedia(projectToMedia bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MediaTypes(mediaTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ImageTypes(imageTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsPlayed(isPlayed bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Genres(genres string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) OfficialRatings(officialRatings string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Tags(tags string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ExcludeTags(excludeTags string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Years(years string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Person(person string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) PersonIds(personIds string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) PersonTypes(personTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Studios(studios string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) StudioIds(studioIds string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Artists(artists string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ArtistIds(artistIds string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Albums(albums string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Ids(ids string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) VideoTypes(videoTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Containers(containers string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) AudioCodecs(audioCodecs string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) AudioLayouts(audioLayouts string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) VideoCodecs(videoCodecs string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ExtendedVideoTypes(extendedVideoTypes string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) SubtitleCodecs(subtitleCodecs string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Path(path string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.path = &path
	return r
}

// User Id
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) UserId(userId string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) MinOfficialRating(minOfficialRating string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsLocked(isLocked bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) IsPlaceHolder(isPlaceHolder bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) HasOfficialRating(hasOfficialRating bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Is3D(is3D bool) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) SeriesStatus(seriesStatus string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) NameStartsWith(nameStartsWith string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) NameLessThan(nameLessThan string) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r LiveTvServiceAPIGetLivetvChanneltagsRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvChanneltagsExecute(r)
}

/*
GetLivetvChanneltags Gets live tv channel tags

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvChanneltagsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChanneltags(ctx context.Context) LiveTvServiceAPIGetLivetvChanneltagsRequest {
	return LiveTvServiceAPIGetLivetvChanneltagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvChanneltagsExecute(r LiveTvServiceAPIGetLivetvChanneltagsRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChanneltags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelTags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ArtistType(artistType string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MaxOfficialRating(maxOfficialRating string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasThemeSong(hasThemeSong bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasThemeVideo(hasThemeVideo bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasSubtitles(hasSubtitles bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasSpecialFeature(hasSpecialFeature bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasTrailer(hasTrailer bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) AdjacentTo(adjacentTo string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinIndexNumber(minIndexNumber int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinStartDate(minStartDate string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MaxStartDate(maxStartDate string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinEndDate(minEndDate string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MaxEndDate(maxEndDate string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinPlayers(minPlayers int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MaxPlayers(maxPlayers int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ParentIndexNumber(parentIndexNumber int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasParentalRating(hasParentalRating bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsHD(isHD bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsUnaired(isUnaired bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinCommunityRating(minCommunityRating float64) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinCriticRating(minCriticRating float64) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) AiredDuringSeason(airedDuringSeason int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinPremiereDate(minPremiereDate string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinDateLastSaved(minDateLastSaved string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MaxPremiereDate(maxPremiereDate string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasOverview(hasOverview bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasImdbId(hasImdbId bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasTmdbId(hasTmdbId bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasTvdbId(hasTvdbId bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ExcludeItemIds(excludeItemIds string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Recursive(recursive bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) SearchTerm(searchTerm string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) SortOrder(sortOrder string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ParentId(parentId string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Fields(fields string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ExcludeItemTypes(excludeItemTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IncludeItemTypes(includeItemTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) AnyProviderIdEquals(anyProviderIdEquals string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Filters(filters string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsFavorite(isFavorite bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsMovie(isMovie bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsSeries(isSeries bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsFolder(isFolder bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsNews(isNews bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsKids(isKids bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsSports(isSports bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsNew(isNew bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsPremiere(isPremiere bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsNewOrPremiere(isNewOrPremiere bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsRepeat(isRepeat bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ProjectToMedia(projectToMedia bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MediaTypes(mediaTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ImageTypes(imageTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsPlayed(isPlayed bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Genres(genres string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) OfficialRatings(officialRatings string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Tags(tags string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ExcludeTags(excludeTags string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Years(years string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Person(person string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) PersonIds(personIds string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) PersonTypes(personTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Studios(studios string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) StudioIds(studioIds string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Artists(artists string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ArtistIds(artistIds string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Albums(albums string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Ids(ids string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) VideoTypes(videoTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Containers(containers string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) AudioCodecs(audioCodecs string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) AudioLayouts(audioLayouts string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) VideoCodecs(videoCodecs string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ExtendedVideoTypes(extendedVideoTypes string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) SubtitleCodecs(subtitleCodecs string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Path(path string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.path = &path
	return r
}

// User Id
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) UserId(userId string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) MinOfficialRating(minOfficialRating string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsLocked(isLocked bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) IsPlaceHolder(isPlaceHolder bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) HasOfficialRating(hasOfficialRating bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Is3D(is3D bool) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) SeriesStatus(seriesStatus string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) NameStartsWith(nameStartsWith string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) NameLessThan(nameLessThan string) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) Execute() ([]ModelLiveTVApiTagItem, *http.Response, error) {
	return r.ApiService.GetLivetvChanneltagsPrefixesExecute(r)
}

/*
GetLivetvChanneltagsPrefixes Gets live tv channel tag prefixes

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChanneltagsPrefixes(ctx context.Context) LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest {
	return LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelLiveTVApiTagItem
func (a *LiveTvServiceAPIService) GetLivetvChanneltagsPrefixesExecute(r LiveTvServiceAPIGetLivetvChanneltagsPrefixesRequest) ([]ModelLiveTVApiTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelLiveTVApiTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChanneltagsPrefixes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelTags/Prefixes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvEPGRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	type_ *ModelLiveTvChannelType
	isLiked *bool
	isDisliked *bool
	enableFavoriteSorting *bool
	addCurrentProgram *bool
	channelIds *string
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Optional filter by channel type.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Type_(type_ ModelLiveTvChannelType) LiveTvServiceAPIGetLivetvEPGRequest {
	r.type_ = &type_
	return r
}

// Filter by channels that are liked, or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsLiked(isLiked bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isLiked = &isLiked
	return r
}

// Filter by channels that are disliked, or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsDisliked(isDisliked bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isDisliked = &isDisliked
	return r
}

// Incorporate favorite and like status into channel sorting.
func (r LiveTvServiceAPIGetLivetvEPGRequest) EnableFavoriteSorting(enableFavoriteSorting bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.enableFavoriteSorting = &enableFavoriteSorting
	return r
}

// Optional. Adds current program info to each channel
func (r LiveTvServiceAPIGetLivetvEPGRequest) AddCurrentProgram(addCurrentProgram bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.addCurrentProgram = &addCurrentProgram
	return r
}

// The channels to return guide information for.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ChannelIds(channelIds string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.channelIds = &channelIds
	return r
}

// Artist or AlbumArtist
func (r LiveTvServiceAPIGetLivetvEPGRequest) ArtistType(artistType string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvEPGRequest) MaxOfficialRating(maxOfficialRating string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasThemeSong(hasThemeSong bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasThemeVideo(hasThemeVideo bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasSubtitles(hasSubtitles bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasSpecialFeature(hasSpecialFeature bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasTrailer(hasTrailer bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r LiveTvServiceAPIGetLivetvEPGRequest) AdjacentTo(adjacentTo string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinIndexNumber(minIndexNumber int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinStartDate(minStartDate string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MaxStartDate(maxStartDate string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinEndDate(minEndDate string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MaxEndDate(maxEndDate string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinPlayers(minPlayers int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r LiveTvServiceAPIGetLivetvEPGRequest) MaxPlayers(maxPlayers int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ParentIndexNumber(parentIndexNumber int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasParentalRating(hasParentalRating bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsHD(isHD bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsUnaired(isUnaired bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinCommunityRating(minCommunityRating float64) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinCriticRating(minCriticRating float64) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r LiveTvServiceAPIGetLivetvEPGRequest) AiredDuringSeason(airedDuringSeason int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinPremiereDate(minPremiereDate string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinDateLastSaved(minDateLastSaved string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvEPGRequest) MaxPremiereDate(maxPremiereDate string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasOverview(hasOverview bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasImdbId(hasImdbId bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasTmdbId(hasTmdbId bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasTvdbId(hasTvdbId bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ExcludeItemIds(excludeItemIds string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvEPGRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvEPGRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r LiveTvServiceAPIGetLivetvEPGRequest) Recursive(recursive bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r LiveTvServiceAPIGetLivetvEPGRequest) SearchTerm(searchTerm string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIGetLivetvEPGRequest) SortOrder(sortOrder string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r LiveTvServiceAPIGetLivetvEPGRequest) ParentId(parentId string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIGetLivetvEPGRequest) Fields(fields string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ExcludeItemTypes(excludeItemTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IncludeItemTypes(includeItemTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r LiveTvServiceAPIGetLivetvEPGRequest) AnyProviderIdEquals(anyProviderIdEquals string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r LiveTvServiceAPIGetLivetvEPGRequest) Filters(filters string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsFavorite(isFavorite bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsMovie(isMovie bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsSeries(isSeries bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsFolder(isFolder bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsNews(isNews bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsKids(isKids bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsSports(isSports bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsNew(isNew bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsPremiere(isPremiere bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsNewOrPremiere(isNewOrPremiere bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsRepeat(isRepeat bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r LiveTvServiceAPIGetLivetvEPGRequest) ProjectToMedia(projectToMedia bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvEPGRequest) MediaTypes(mediaTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ImageTypes(imageTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r LiveTvServiceAPIGetLivetvEPGRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsPlayed(isPlayed bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Genres(genres string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) OfficialRatings(officialRatings string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Tags(tags string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ExcludeTags(excludeTags string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Years(years string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvEPGRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvEPGRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvEPGRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvEPGRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvEPGRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Person(person string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvEPGRequest) PersonIds(personIds string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r LiveTvServiceAPIGetLivetvEPGRequest) PersonTypes(personTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Studios(studios string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) StudioIds(studioIds string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Artists(artists string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ArtistIds(artistIds string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Albums(albums string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Ids(ids string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) VideoTypes(videoTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Containers(containers string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) AudioCodecs(audioCodecs string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) AudioLayouts(audioLayouts string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) VideoCodecs(videoCodecs string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ExtendedVideoTypes(extendedVideoTypes string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) SubtitleCodecs(subtitleCodecs string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Path(path string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.path = &path
	return r
}

// User Id
func (r LiveTvServiceAPIGetLivetvEPGRequest) UserId(userId string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvEPGRequest) MinOfficialRating(minOfficialRating string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsLocked(isLocked bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r LiveTvServiceAPIGetLivetvEPGRequest) IsPlaceHolder(isPlaceHolder bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r LiveTvServiceAPIGetLivetvEPGRequest) HasOfficialRating(hasOfficialRating bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r LiveTvServiceAPIGetLivetvEPGRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r LiveTvServiceAPIGetLivetvEPGRequest) Is3D(is3D bool) LiveTvServiceAPIGetLivetvEPGRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvEPGRequest) SeriesStatus(seriesStatus string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvEPGRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvEPGRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvEPGRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r LiveTvServiceAPIGetLivetvEPGRequest) NameStartsWith(nameStartsWith string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r LiveTvServiceAPIGetLivetvEPGRequest) NameLessThan(nameLessThan string) LiveTvServiceAPIGetLivetvEPGRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r LiveTvServiceAPIGetLivetvEPGRequest) Execute() (*ModelQueryResultLiveTVApiEpgRow, *http.Response, error) {
	return r.ApiService.GetLivetvEPGExecute(r)
}

/*
GetLivetvEPG Gets the epg.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvEPGRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvEPG(ctx context.Context) LiveTvServiceAPIGetLivetvEPGRequest {
	return LiveTvServiceAPIGetLivetvEPGRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultLiveTVApiEpgRow
func (a *LiveTvServiceAPIService) GetLivetvEPGExecute(r LiveTvServiceAPIGetLivetvEPGRequest) (*ModelQueryResultLiveTVApiEpgRow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultLiveTVApiEpgRow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvEPG")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/EPG"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Type", r.type_, "")
	}
	if r.isLiked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLiked", r.isLiked, "")
	}
	if r.isDisliked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsDisliked", r.isDisliked, "")
	}
	if r.enableFavoriteSorting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableFavoriteSorting", r.enableFavoriteSorting, "")
	}
	if r.addCurrentProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AddCurrentProgram", r.addCurrentProgram, "")
	}
	if r.channelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelIds", r.channelIds, "")
	}
	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvFolderRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvFolderRequest) Execute() (*ModelBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvFolderExecute(r)
}

/*
GetLivetvFolder Gets the top level live tv folder

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvFolderRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvFolder(ctx context.Context) LiveTvServiceAPIGetLivetvFolderRequest {
	return LiveTvServiceAPIGetLivetvFolderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvFolderExecute(r LiveTvServiceAPIGetLivetvFolderRequest) (*ModelBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Folder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvGuideinfoRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvGuideinfoRequest) Execute() (*ModelLiveTvGuideInfo, *http.Response, error) {
	return r.ApiService.GetLivetvGuideinfoExecute(r)
}

/*
GetLivetvGuideinfo Gets guide info

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvGuideinfoRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvGuideinfo(ctx context.Context) LiveTvServiceAPIGetLivetvGuideinfoRequest {
	return LiveTvServiceAPIGetLivetvGuideinfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLiveTvGuideInfo
func (a *LiveTvServiceAPIService) GetLivetvGuideinfoExecute(r LiveTvServiceAPIGetLivetvGuideinfoRequest) (*ModelLiveTvGuideInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvGuideInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvGuideinfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/GuideInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvInfoRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvInfoRequest) Execute() (*ModelLiveTvLiveTvInfo, *http.Response, error) {
	return r.ApiService.GetLivetvInfoExecute(r)
}

/*
GetLivetvInfo Gets available live tv services.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvInfoRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvInfo(ctx context.Context) LiveTvServiceAPIGetLivetvInfoRequest {
	return LiveTvServiceAPIGetLivetvInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLiveTvLiveTvInfo
func (a *LiveTvServiceAPIService) GetLivetvInfoExecute(r LiveTvServiceAPIGetLivetvInfoRequest) (*ModelLiveTvLiveTvInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvLiveTvInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvListingprovidersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	channelId *string
}

// Channel id
func (r LiveTvServiceAPIGetLivetvListingprovidersRequest) ChannelId(channelId string) LiveTvServiceAPIGetLivetvListingprovidersRequest {
	r.channelId = &channelId
	return r
}

func (r LiveTvServiceAPIGetLivetvListingprovidersRequest) Execute() ([]ModelLiveTvListingsProviderInfo, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersExecute(r)
}

/*
GetLivetvListingproviders Gets current listing providers

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvListingprovidersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingproviders(ctx context.Context) LiveTvServiceAPIGetLivetvListingprovidersRequest {
	return LiveTvServiceAPIGetLivetvListingprovidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelLiveTvListingsProviderInfo
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersExecute(r LiveTvServiceAPIGetLivetvListingprovidersRequest) ([]ModelLiveTvListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelLiveTvListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingproviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelId", r.channelId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvListingprovidersAvailableRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvListingprovidersAvailableRequest) Execute() ([]ModelLiveTVApiListingProviderTypeInfo, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersAvailableExecute(r)
}

/*
GetLivetvListingprovidersAvailable Gets listing provider

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvListingprovidersAvailableRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersAvailable(ctx context.Context) LiveTvServiceAPIGetLivetvListingprovidersAvailableRequest {
	return LiveTvServiceAPIGetLivetvListingprovidersAvailableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelLiveTVApiListingProviderTypeInfo
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersAvailableExecute(r LiveTvServiceAPIGetLivetvListingprovidersAvailableRequest) ([]ModelLiveTVApiListingProviderTypeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelLiveTVApiListingProviderTypeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Available"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvListingprovidersDefaultRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvListingprovidersDefaultRequest) Execute() (*ModelLiveTvListingsProviderInfo, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersDefaultExecute(r)
}

/*
GetLivetvListingprovidersDefault Method for GetLivetvListingprovidersDefault

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvListingprovidersDefaultRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersDefault(ctx context.Context) LiveTvServiceAPIGetLivetvListingprovidersDefaultRequest {
	return LiveTvServiceAPIGetLivetvListingprovidersDefaultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLiveTvListingsProviderInfo
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersDefaultExecute(r LiveTvServiceAPIGetLivetvListingprovidersDefaultRequest) (*ModelLiveTvListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersDefault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id *string
	type_ *string
	location *string
	country *string
}

// Provider id
func (r LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest) Id(id string) LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest {
	r.id = &id
	return r
}

// Provider Type
func (r LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest) Type_(type_ string) LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest {
	r.type_ = &type_
	return r
}

// Location
func (r LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest) Location(location string) LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest {
	r.location = &location
	return r
}

// Country
func (r LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest) Country(country string) LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest {
	r.country = &country
	return r
}

func (r LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest) Execute() ([]ModelNameIdPair, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersLineupsExecute(r)
}

/*
GetLivetvListingprovidersLineups Gets available lineups

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersLineups(ctx context.Context) LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest {
	return LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelNameIdPair
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersLineupsExecute(r LiveTvServiceAPIGetLivetvListingprovidersLineupsRequest) ([]ModelNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersLineups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Lineups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Type", r.type_, "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Location", r.location, "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Country", r.country, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvListingprovidersSchedulesdirectCountriesRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvListingprovidersSchedulesdirectCountriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersSchedulesdirectCountriesExecute(r)
}

/*
GetLivetvListingprovidersSchedulesdirectCountries Gets available lineups

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvListingprovidersSchedulesdirectCountriesRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersSchedulesdirectCountries(ctx context.Context) LiveTvServiceAPIGetLivetvListingprovidersSchedulesdirectCountriesRequest {
	return LiveTvServiceAPIGetLivetvListingprovidersSchedulesdirectCountriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersSchedulesdirectCountriesExecute(r LiveTvServiceAPIGetLivetvListingprovidersSchedulesdirectCountriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersSchedulesdirectCountries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/SchedulesDirect/Countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvLiverecordingsByIdStreamRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIGetLivetvLiverecordingsByIdStreamRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvLiverecordingsByIdStreamExecute(r)
}

/*
GetLivetvLiverecordingsByIdStream Gets a live tv channel

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LiveTvServiceAPIGetLivetvLiverecordingsByIdStreamRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvLiverecordingsByIdStream(ctx context.Context, id string) LiveTvServiceAPIGetLivetvLiverecordingsByIdStreamRequest {
	return LiveTvServiceAPIGetLivetvLiverecordingsByIdStreamRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvLiverecordingsByIdStreamExecute(r LiveTvServiceAPIGetLivetvLiverecordingsByIdStreamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvLiverecordingsByIdStream")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveRecordings/{Id}/stream"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvLivestreamfilesByIdStreamByContainerRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
	container string
}

func (r LiveTvServiceAPIGetLivetvLivestreamfilesByIdStreamByContainerRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvLivestreamfilesByIdStreamByContainerExecute(r)
}

/*
GetLivetvLivestreamfilesByIdStreamByContainer Gets a live tv channel

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param container
 @return LiveTvServiceAPIGetLivetvLivestreamfilesByIdStreamByContainerRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvLivestreamfilesByIdStreamByContainer(ctx context.Context, id string, container string) LiveTvServiceAPIGetLivetvLivestreamfilesByIdStreamByContainerRequest {
	return LiveTvServiceAPIGetLivetvLivestreamfilesByIdStreamByContainerRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		container: container,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvLivestreamfilesByIdStreamByContainerExecute(r LiveTvServiceAPIGetLivetvLivestreamfilesByIdStreamByContainerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvLivestreamfilesByIdStreamByContainer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveStreamFiles/{Id}/stream.{Container}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvManageChannelsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	startIndex *int32
	limit *int32
	sortBy *string
	sortOrder *string
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvManageChannelsRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvManageChannelsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvManageChannelsRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvManageChannelsRequest {
	r.limit = &limit
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
func (r LiveTvServiceAPIGetLivetvManageChannelsRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvManageChannelsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIGetLivetvManageChannelsRequest) SortOrder(sortOrder string) LiveTvServiceAPIGetLivetvManageChannelsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r LiveTvServiceAPIGetLivetvManageChannelsRequest) Execute() (*ModelQueryResultChannelManagementInfo, *http.Response, error) {
	return r.ApiService.GetLivetvManageChannelsExecute(r)
}

/*
GetLivetvManageChannels Gets the channel management list

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvManageChannelsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvManageChannels(ctx context.Context) LiveTvServiceAPIGetLivetvManageChannelsRequest {
	return LiveTvServiceAPIGetLivetvManageChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultChannelManagementInfo
func (a *LiveTvServiceAPIService) GetLivetvManageChannelsExecute(r LiveTvServiceAPIGetLivetvManageChannelsRequest) (*ModelQueryResultChannelManagementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultChannelManagementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvManageChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Manage/Channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvProgramsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	channelIds *string
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// The channels to return guide information for.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ChannelIds(channelIds string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.channelIds = &channelIds
	return r
}

// Artist or AlbumArtist
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ArtistType(artistType string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MaxOfficialRating(maxOfficialRating string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasThemeSong(hasThemeSong bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasThemeVideo(hasThemeVideo bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasSubtitles(hasSubtitles bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasSpecialFeature(hasSpecialFeature bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasTrailer(hasTrailer bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) AdjacentTo(adjacentTo string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinIndexNumber(minIndexNumber int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinStartDate(minStartDate string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MaxStartDate(maxStartDate string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinEndDate(minEndDate string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MaxEndDate(maxEndDate string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinPlayers(minPlayers int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MaxPlayers(maxPlayers int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ParentIndexNumber(parentIndexNumber int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasParentalRating(hasParentalRating bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsHD(isHD bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsUnaired(isUnaired bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinCommunityRating(minCommunityRating float64) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinCriticRating(minCriticRating float64) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) AiredDuringSeason(airedDuringSeason int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinPremiereDate(minPremiereDate string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinDateLastSaved(minDateLastSaved string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MaxPremiereDate(maxPremiereDate string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasOverview(hasOverview bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasImdbId(hasImdbId bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasTmdbId(hasTmdbId bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasTvdbId(hasTvdbId bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ExcludeItemIds(excludeItemIds string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Recursive(recursive bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r LiveTvServiceAPIGetLivetvProgramsRequest) SearchTerm(searchTerm string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIGetLivetvProgramsRequest) SortOrder(sortOrder string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ParentId(parentId string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Fields(fields string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ExcludeItemTypes(excludeItemTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IncludeItemTypes(includeItemTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) AnyProviderIdEquals(anyProviderIdEquals string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Filters(filters string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsFavorite(isFavorite bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsMovie(isMovie bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsSeries(isSeries bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsFolder(isFolder bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsNews(isNews bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsKids(isKids bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsSports(isSports bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsNew(isNew bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsPremiere(isPremiere bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsNewOrPremiere(isNewOrPremiere bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsRepeat(isRepeat bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ProjectToMedia(projectToMedia bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MediaTypes(mediaTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ImageTypes(imageTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r LiveTvServiceAPIGetLivetvProgramsRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsPlayed(isPlayed bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Genres(genres string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) OfficialRatings(officialRatings string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Tags(tags string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ExcludeTags(excludeTags string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Years(years string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvProgramsRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvProgramsRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Person(person string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) PersonIds(personIds string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r LiveTvServiceAPIGetLivetvProgramsRequest) PersonTypes(personTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Studios(studios string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) StudioIds(studioIds string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Artists(artists string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ArtistIds(artistIds string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Albums(albums string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Ids(ids string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) VideoTypes(videoTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Containers(containers string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) AudioCodecs(audioCodecs string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) AudioLayouts(audioLayouts string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) VideoCodecs(videoCodecs string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ExtendedVideoTypes(extendedVideoTypes string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) SubtitleCodecs(subtitleCodecs string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Path(path string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.path = &path
	return r
}

// User Id
func (r LiveTvServiceAPIGetLivetvProgramsRequest) UserId(userId string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvProgramsRequest) MinOfficialRating(minOfficialRating string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsLocked(isLocked bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r LiveTvServiceAPIGetLivetvProgramsRequest) IsPlaceHolder(isPlaceHolder bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r LiveTvServiceAPIGetLivetvProgramsRequest) HasOfficialRating(hasOfficialRating bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) Is3D(is3D bool) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) SeriesStatus(seriesStatus string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) NameStartsWith(nameStartsWith string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r LiveTvServiceAPIGetLivetvProgramsRequest) NameLessThan(nameLessThan string) LiveTvServiceAPIGetLivetvProgramsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r LiveTvServiceAPIGetLivetvProgramsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvProgramsExecute(r)
}

/*
GetLivetvPrograms Gets available live tv epgs..

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvProgramsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvPrograms(ctx context.Context) LiveTvServiceAPIGetLivetvProgramsRequest {
	return LiveTvServiceAPIGetLivetvProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvProgramsExecute(r LiveTvServiceAPIGetLivetvProgramsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvPrograms")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelIds", r.channelIds, "")
	}
	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvProgramsRecommendedRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	userId *string
	limit *int32
	isAiring *bool
	hasAired *bool
	isSeries *bool
	isMovie *bool
	isNews *bool
	isKids *bool
	isSports *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	genreIds *string
	fields *string
	enableUserData *bool
}

// Optional filter by user id.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) UserId(userId string) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by programs that are currently airing, or not.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) IsAiring(isAiring bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.isAiring = &isAiring
	return r
}

// Optional. Filter by programs that have completed airing, or not.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) HasAired(hasAired bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.hasAired = &hasAired
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) IsSeries(isSeries bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) IsMovie(isMovie bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) IsNews(isNews bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) IsKids(isKids bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) IsSports(isSports bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.isSports = &isSports
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// The genres to return guide information for.
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) GenreIds(genreIds string) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.genreIds = &genreIds
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) Fields(fields string) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.fields = &fields
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	r.enableUserData = &enableUserData
	return r
}

func (r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvProgramsRecommendedExecute(r)
}

/*
GetLivetvProgramsRecommended Gets available live tv epgs..

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvProgramsRecommendedRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvProgramsRecommended(ctx context.Context) LiveTvServiceAPIGetLivetvProgramsRecommendedRequest {
	return LiveTvServiceAPIGetLivetvProgramsRecommendedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvProgramsRecommendedExecute(r LiveTvServiceAPIGetLivetvProgramsRecommendedRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvProgramsRecommended")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs/Recommended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.isAiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsAiring", r.isAiring, "")
	}
	if r.hasAired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasAired", r.hasAired, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.genreIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GenreIds", r.genreIds, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvRecordingsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	channelId *string
	status *ModelLiveTvRecordingStatus
	isInProgress *bool
	seriesTimerId *string
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Optional filter by channel id.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ChannelId(channelId string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.channelId = &channelId
	return r
}

// Optional filter by recording status.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Status(status ModelLiveTvRecordingStatus) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.status = &status
	return r
}

// Optional filter by recordings that are in progress, or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsInProgress(isInProgress bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isInProgress = &isInProgress
	return r
}

// Optional filter by recordings belonging to a series timer
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) SeriesTimerId(seriesTimerId string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Artist or AlbumArtist
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ArtistType(artistType string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MaxOfficialRating(maxOfficialRating string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasThemeSong(hasThemeSong bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasThemeVideo(hasThemeVideo bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasSubtitles(hasSubtitles bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasSpecialFeature(hasSpecialFeature bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasTrailer(hasTrailer bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) AdjacentTo(adjacentTo string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinIndexNumber(minIndexNumber int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinStartDate(minStartDate string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MaxStartDate(maxStartDate string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinEndDate(minEndDate string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MaxEndDate(maxEndDate string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinPlayers(minPlayers int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MaxPlayers(maxPlayers int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ParentIndexNumber(parentIndexNumber int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasParentalRating(hasParentalRating bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsHD(isHD bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsUnaired(isUnaired bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinCommunityRating(minCommunityRating float64) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinCriticRating(minCriticRating float64) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) AiredDuringSeason(airedDuringSeason int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinPremiereDate(minPremiereDate string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinDateLastSaved(minDateLastSaved string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MaxPremiereDate(maxPremiereDate string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasOverview(hasOverview bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasImdbId(hasImdbId bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasTmdbId(hasTmdbId bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasTvdbId(hasTvdbId bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ExcludeItemIds(excludeItemIds string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Recursive(recursive bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) SearchTerm(searchTerm string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) SortOrder(sortOrder string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ParentId(parentId string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Fields(fields string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ExcludeItemTypes(excludeItemTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IncludeItemTypes(includeItemTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) AnyProviderIdEquals(anyProviderIdEquals string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Filters(filters string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsFavorite(isFavorite bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsMovie(isMovie bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsSeries(isSeries bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsFolder(isFolder bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsNews(isNews bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsKids(isKids bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsSports(isSports bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsNew(isNew bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsPremiere(isPremiere bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsNewOrPremiere(isNewOrPremiere bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsRepeat(isRepeat bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ProjectToMedia(projectToMedia bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MediaTypes(mediaTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ImageTypes(imageTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsPlayed(isPlayed bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Genres(genres string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) OfficialRatings(officialRatings string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Tags(tags string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ExcludeTags(excludeTags string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Years(years string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Person(person string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) PersonIds(personIds string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) PersonTypes(personTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Studios(studios string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) StudioIds(studioIds string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Artists(artists string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ArtistIds(artistIds string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Albums(albums string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Ids(ids string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) VideoTypes(videoTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Containers(containers string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) AudioCodecs(audioCodecs string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) AudioLayouts(audioLayouts string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) VideoCodecs(videoCodecs string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ExtendedVideoTypes(extendedVideoTypes string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) SubtitleCodecs(subtitleCodecs string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Path(path string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.path = &path
	return r
}

// User Id
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) UserId(userId string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) MinOfficialRating(minOfficialRating string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsLocked(isLocked bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) IsPlaceHolder(isPlaceHolder bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) HasOfficialRating(hasOfficialRating bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Is3D(is3D bool) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) SeriesStatus(seriesStatus string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) NameStartsWith(nameStartsWith string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r LiveTvServiceAPIGetLivetvRecordingsRequest) NameLessThan(nameLessThan string) LiveTvServiceAPIGetLivetvRecordingsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r LiveTvServiceAPIGetLivetvRecordingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvRecordingsExecute(r)
}

/*
GetLivetvRecordings Gets live tv recordings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvRecordingsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordings(ctx context.Context) LiveTvServiceAPIGetLivetvRecordingsRequest {
	return LiveTvServiceAPIGetLivetvRecordingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvRecordingsExecute(r LiveTvServiceAPIGetLivetvRecordingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelId", r.channelId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "")
	}
	if r.isInProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsInProgress", r.isInProgress, "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesTimerId", r.seriesTimerId, "")
	}
	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvRecordingsByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
	userId *string
}

// Optional attach user data.
func (r LiveTvServiceAPIGetLivetvRecordingsByIdRequest) UserId(userId string) LiveTvServiceAPIGetLivetvRecordingsByIdRequest {
	r.userId = &userId
	return r
}

func (r LiveTvServiceAPIGetLivetvRecordingsByIdRequest) Execute() (*ModelBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsByIdExecute(r)
}

/*
GetLivetvRecordingsById Gets a live tv recording

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Recording Id
 @return LiveTvServiceAPIGetLivetvRecordingsByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsById(ctx context.Context, id string) LiveTvServiceAPIGetLivetvRecordingsByIdRequest {
	return LiveTvServiceAPIGetLivetvRecordingsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsByIdExecute(r LiveTvServiceAPIGetLivetvRecordingsByIdRequest) (*ModelBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvRecordingsFoldersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	userId *string
	fields *string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	enableUserData *bool
}

// Optional filter by user and attach user data.
func (r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) UserId(userId string) LiveTvServiceAPIGetLivetvRecordingsFoldersRequest {
	r.userId = &userId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) Fields(fields string) LiveTvServiceAPIGetLivetvRecordingsFoldersRequest {
	r.fields = &fields
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) EnableImages(enableImages bool) LiveTvServiceAPIGetLivetvRecordingsFoldersRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIGetLivetvRecordingsFoldersRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIGetLivetvRecordingsFoldersRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIGetLivetvRecordingsFoldersRequest {
	r.enableUserData = &enableUserData
	return r
}

func (r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) Execute() ([]ModelBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsFoldersExecute(r)
}

/*
GetLivetvRecordingsFolders Gets recording folders

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvRecordingsFoldersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsFolders(ctx context.Context) LiveTvServiceAPIGetLivetvRecordingsFoldersRequest {
	return LiveTvServiceAPIGetLivetvRecordingsFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsFoldersExecute(r LiveTvServiceAPIGetLivetvRecordingsFoldersRequest) ([]ModelBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvRecordingsGroupsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvRecordingsGroupsRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsGroupsExecute(r)
}

/*
GetLivetvRecordingsGroups Gets live tv recording groups

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvRecordingsGroupsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsGroups(ctx context.Context) LiveTvServiceAPIGetLivetvRecordingsGroupsRequest {
	return LiveTvServiceAPIGetLivetvRecordingsGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsGroupsExecute(r LiveTvServiceAPIGetLivetvRecordingsGroupsRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvRecordingsSeriesRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvRecordingsSeriesRequest) Execute() (*ModelQueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsSeriesExecute(r)
}

/*
GetLivetvRecordingsSeries Gets live tv recordings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvRecordingsSeriesRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsSeries(ctx context.Context) LiveTvServiceAPIGetLivetvRecordingsSeriesRequest {
	return LiveTvServiceAPIGetLivetvRecordingsSeriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsSeriesExecute(r LiveTvServiceAPIGetLivetvRecordingsSeriesRequest) (*ModelQueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Series"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvSeriestimersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	sortBy *string
	sortOrder *ModelSortOrder
	startIndex *int32
	limit *int32
}

// Optional. Sort by SortName or Priority
func (r LiveTvServiceAPIGetLivetvSeriestimersRequest) SortBy(sortBy string) LiveTvServiceAPIGetLivetvSeriestimersRequest {
	r.sortBy = &sortBy
	return r
}

// Optional. Sort in Ascending or Descending order
func (r LiveTvServiceAPIGetLivetvSeriestimersRequest) SortOrder(sortOrder ModelSortOrder) LiveTvServiceAPIGetLivetvSeriestimersRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIGetLivetvSeriestimersRequest) StartIndex(startIndex int32) LiveTvServiceAPIGetLivetvSeriestimersRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIGetLivetvSeriestimersRequest) Limit(limit int32) LiveTvServiceAPIGetLivetvSeriestimersRequest {
	r.limit = &limit
	return r
}

func (r LiveTvServiceAPIGetLivetvSeriestimersRequest) Execute() (*ModelQueryResultLiveTvSeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvSeriestimersExecute(r)
}

/*
GetLivetvSeriestimers Gets live tv series timers

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvSeriestimersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvSeriestimers(ctx context.Context) LiveTvServiceAPIGetLivetvSeriestimersRequest {
	return LiveTvServiceAPIGetLivetvSeriestimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultLiveTvSeriesTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvSeriestimersExecute(r LiveTvServiceAPIGetLivetvSeriestimersRequest) (*ModelQueryResultLiveTvSeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultLiveTvSeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvSeriestimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvSeriestimersByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIGetLivetvSeriestimersByIdRequest) Execute() (*ModelLiveTvTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvSeriestimersByIdExecute(r)
}

/*
GetLivetvSeriestimersById Gets a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return LiveTvServiceAPIGetLivetvSeriestimersByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvSeriestimersById(ctx context.Context, id string) LiveTvServiceAPIGetLivetvSeriestimersByIdRequest {
	return LiveTvServiceAPIGetLivetvSeriestimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelLiveTvTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvSeriestimersByIdExecute(r LiveTvServiceAPIGetLivetvSeriestimersByIdRequest) (*ModelLiveTvTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvSeriestimersById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvTimersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	channelId *string
	seriesTimerId *string
}

// Optional filter by channel id.
func (r LiveTvServiceAPIGetLivetvTimersRequest) ChannelId(channelId string) LiveTvServiceAPIGetLivetvTimersRequest {
	r.channelId = &channelId
	return r
}

// Optional filter by timers belonging to a series timer
func (r LiveTvServiceAPIGetLivetvTimersRequest) SeriesTimerId(seriesTimerId string) LiveTvServiceAPIGetLivetvTimersRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

func (r LiveTvServiceAPIGetLivetvTimersRequest) Execute() (*ModelQueryResultLiveTvTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvTimersExecute(r)
}

/*
GetLivetvTimers Gets live tv timers

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvTimersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTimers(ctx context.Context) LiveTvServiceAPIGetLivetvTimersRequest {
	return LiveTvServiceAPIGetLivetvTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelQueryResultLiveTvTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvTimersExecute(r LiveTvServiceAPIGetLivetvTimersRequest) (*ModelQueryResultLiveTvTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultLiveTvTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelId", r.channelId, "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesTimerId", r.seriesTimerId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvTimersByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIGetLivetvTimersByIdRequest) Execute() (*ModelLiveTvTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvTimersByIdExecute(r)
}

/*
GetLivetvTimersById Gets a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return LiveTvServiceAPIGetLivetvTimersByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTimersById(ctx context.Context, id string) LiveTvServiceAPIGetLivetvTimersByIdRequest {
	return LiveTvServiceAPIGetLivetvTimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelLiveTvTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvTimersByIdExecute(r LiveTvServiceAPIGetLivetvTimersByIdRequest) (*ModelLiveTvTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTimersById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvTimersDefaultsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	programId *string
}

// Optional, to attach default values based on a program.
func (r LiveTvServiceAPIGetLivetvTimersDefaultsRequest) ProgramId(programId string) LiveTvServiceAPIGetLivetvTimersDefaultsRequest {
	r.programId = &programId
	return r
}

func (r LiveTvServiceAPIGetLivetvTimersDefaultsRequest) Execute() (*ModelLiveTvSeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvTimersDefaultsExecute(r)
}

/*
GetLivetvTimersDefaults Gets default values for a new timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvTimersDefaultsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTimersDefaults(ctx context.Context) LiveTvServiceAPIGetLivetvTimersDefaultsRequest {
	return LiveTvServiceAPIGetLivetvTimersDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLiveTvSeriesTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvTimersDefaultsExecute(r LiveTvServiceAPIGetLivetvTimersDefaultsRequest) (*ModelLiveTvSeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvSeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTimersDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/Defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.programId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProgramId", r.programId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvTunerhostsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvTunerhostsRequest) Execute() ([]ModelLiveTvTunerHostInfo, *http.Response, error) {
	return r.ApiService.GetLivetvTunerhostsExecute(r)
}

/*
GetLivetvTunerhosts Gets tuner hosts

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvTunerhostsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTunerhosts(ctx context.Context) LiveTvServiceAPIGetLivetvTunerhostsRequest {
	return LiveTvServiceAPIGetLivetvTunerhostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelLiveTvTunerHostInfo
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsExecute(r LiveTvServiceAPIGetLivetvTunerhostsRequest) ([]ModelLiveTvTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelLiveTvTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTunerhosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvTunerhostsDefaultByTypeRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	type_ string
}

func (r LiveTvServiceAPIGetLivetvTunerhostsDefaultByTypeRequest) Execute() (*ModelLiveTvTunerHostInfo, *http.Response, error) {
	return r.ApiService.GetLivetvTunerhostsDefaultByTypeExecute(r)
}

/*
GetLivetvTunerhostsDefaultByType Gets tuner hosts

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Type
 @return LiveTvServiceAPIGetLivetvTunerhostsDefaultByTypeRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsDefaultByType(ctx context.Context, type_ string) LiveTvServiceAPIGetLivetvTunerhostsDefaultByTypeRequest {
	return LiveTvServiceAPIGetLivetvTunerhostsDefaultByTypeRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ModelLiveTvTunerHostInfo
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsDefaultByTypeExecute(r LiveTvServiceAPIGetLivetvTunerhostsDefaultByTypeRequest) (*ModelLiveTvTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTunerhostsDefaultByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts/Default/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvTunerhostsTypesRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvTunerhostsTypesRequest) Execute() ([]ModelNameIdPair, *http.Response, error) {
	return r.ApiService.GetLivetvTunerhostsTypesExecute(r)
}

/*
GetLivetvTunerhostsTypes Method for GetLivetvTunerhostsTypes

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvTunerhostsTypesRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsTypes(ctx context.Context) LiveTvServiceAPIGetLivetvTunerhostsTypesRequest {
	return LiveTvServiceAPIGetLivetvTunerhostsTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelNameIdPair
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsTypesExecute(r LiveTvServiceAPIGetLivetvTunerhostsTypesRequest) ([]ModelNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTunerhostsTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIGetLivetvTunersDiscvoverRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
}

func (r LiveTvServiceAPIGetLivetvTunersDiscvoverRequest) Execute() ([]ModelLiveTvTunerHostInfo, *http.Response, error) {
	return r.ApiService.GetLivetvTunersDiscvoverExecute(r)
}

/*
GetLivetvTunersDiscvover Method for GetLivetvTunersDiscvover

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIGetLivetvTunersDiscvoverRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTunersDiscvover(ctx context.Context) LiveTvServiceAPIGetLivetvTunersDiscvoverRequest {
	return LiveTvServiceAPIGetLivetvTunersDiscvoverRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelLiveTvTunerHostInfo
func (a *LiveTvServiceAPIService) GetLivetvTunersDiscvoverExecute(r LiveTvServiceAPIGetLivetvTunersDiscvoverRequest) ([]ModelLiveTvTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelLiveTvTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTunersDiscvover")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/Discvover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest) ProviderId(providerId string) LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadLivetvChannelmappingoptionsExecute(r)
}

/*
HeadLivetvChannelmappingoptions Method for HeadLivetvChannelmappingoptions

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappingoptions(ctx context.Context) LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest {
	return LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappingoptionsExecute(r LiveTvServiceAPIHeadLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.HeadLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIHeadLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIHeadLivetvChannelmappingsRequest) ProviderId(providerId string) LiveTvServiceAPIHeadLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIHeadLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadLivetvChannelmappingsExecute(r)
}

/*
HeadLivetvChannelmappings Method for HeadLivetvChannelmappings

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIHeadLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappings(ctx context.Context) LiveTvServiceAPIHeadLivetvChannelmappingsRequest {
	return LiveTvServiceAPIHeadLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappingsExecute(r LiveTvServiceAPIHeadLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.HeadLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest) ProviderId(providerId string) LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvChannelmappingoptionsExecute(r)
}

/*
PostLivetvChannelmappingoptions Method for PostLivetvChannelmappingoptions

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvChannelmappingoptions(ctx context.Context) LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest {
	return LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvChannelmappingoptionsExecute(r LiveTvServiceAPIPostLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
	modelLiveTVApiSetChannelMapping *ModelLiveTVApiSetChannelMapping
}

// Provider id
func (r LiveTvServiceAPIPostLivetvChannelmappingsRequest) ProviderId(providerId string) LiveTvServiceAPIPostLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

// SetChannelMapping
func (r LiveTvServiceAPIPostLivetvChannelmappingsRequest) ModelLiveTVApiSetChannelMapping(modelLiveTVApiSetChannelMapping ModelLiveTVApiSetChannelMapping) LiveTvServiceAPIPostLivetvChannelmappingsRequest {
	r.modelLiveTVApiSetChannelMapping = &modelLiveTVApiSetChannelMapping
	return r
}

func (r LiveTvServiceAPIPostLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvChannelmappingsExecute(r)
}

/*
PostLivetvChannelmappings Method for PostLivetvChannelmappings

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvChannelmappings(ctx context.Context) LiveTvServiceAPIPostLivetvChannelmappingsRequest {
	return LiveTvServiceAPIPostLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvChannelmappingsExecute(r LiveTvServiceAPIPostLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}
	if r.modelLiveTVApiSetChannelMapping == nil {
		return nil, reportError("modelLiveTVApiSetChannelMapping is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTVApiSetChannelMapping
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvListingprovidersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	modelLiveTvListingsProviderInfo *ModelLiveTvListingsProviderInfo
}

// ListingsProviderInfo: 
func (r LiveTvServiceAPIPostLivetvListingprovidersRequest) ModelLiveTvListingsProviderInfo(modelLiveTvListingsProviderInfo ModelLiveTvListingsProviderInfo) LiveTvServiceAPIPostLivetvListingprovidersRequest {
	r.modelLiveTvListingsProviderInfo = &modelLiveTvListingsProviderInfo
	return r
}

func (r LiveTvServiceAPIPostLivetvListingprovidersRequest) Execute() (*ModelLiveTvListingsProviderInfo, *http.Response, error) {
	return r.ApiService.PostLivetvListingprovidersExecute(r)
}

/*
PostLivetvListingproviders Adds a listing provider

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvListingprovidersRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvListingproviders(ctx context.Context) LiveTvServiceAPIPostLivetvListingprovidersRequest {
	return LiveTvServiceAPIPostLivetvListingprovidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLiveTvListingsProviderInfo
func (a *LiveTvServiceAPIService) PostLivetvListingprovidersExecute(r LiveTvServiceAPIPostLivetvListingprovidersRequest) (*ModelLiveTvListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvListingproviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTvListingsProviderInfo == nil {
		return localVarReturnValue, nil, reportError("modelLiveTvListingsProviderInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTvListingsProviderInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id *string
}

// Provider id
func (r LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest) Id(id string) LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest {
	r.id = &id
	return r
}

func (r LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvListingprovidersDeleteExecute(r)
}

/*
PostLivetvListingprovidersDelete Deletes a listing provider

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvListingprovidersDelete(ctx context.Context) LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest {
	return LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvListingprovidersDeleteExecute(r LiveTvServiceAPIPostLivetvListingprovidersDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvListingprovidersDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
	modelLiveTVApiSetChannelDisabled *ModelLiveTVApiSetChannelDisabled
}

// SetChannelDisabled
func (r LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest) ModelLiveTVApiSetChannelDisabled(modelLiveTVApiSetChannelDisabled ModelLiveTVApiSetChannelDisabled) LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest {
	r.modelLiveTVApiSetChannelDisabled = &modelLiveTVApiSetChannelDisabled
	return r
}

func (r LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest) Execute() (*ModelQueryResultChannelManagementInfo, *http.Response, error) {
	return r.ApiService.PostLivetvManageChannelsByIdDisabledExecute(r)
}

/*
PostLivetvManageChannelsByIdDisabled Sets a channel disabled or not

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvManageChannelsByIdDisabled(ctx context.Context, id string) LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest {
	return LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultChannelManagementInfo
func (a *LiveTvServiceAPIService) PostLivetvManageChannelsByIdDisabledExecute(r LiveTvServiceAPIPostLivetvManageChannelsByIdDisabledRequest) (*ModelQueryResultChannelManagementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultChannelManagementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvManageChannelsByIdDisabled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Manage/Channels/{Id}/Disabled"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTVApiSetChannelDisabled == nil {
		return localVarReturnValue, nil, reportError("modelLiveTVApiSetChannelDisabled is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTVApiSetChannelDisabled
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
	modelLiveTVApiSetChannelSortIndex *ModelLiveTVApiSetChannelSortIndex
}

// SetChannelSortIndex
func (r LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest) ModelLiveTVApiSetChannelSortIndex(modelLiveTVApiSetChannelSortIndex ModelLiveTVApiSetChannelSortIndex) LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest {
	r.modelLiveTVApiSetChannelSortIndex = &modelLiveTVApiSetChannelSortIndex
	return r
}

func (r LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest) Execute() (*ModelQueryResultChannelManagementInfo, *http.Response, error) {
	return r.ApiService.PostLivetvManageChannelsByIdSortindexExecute(r)
}

/*
PostLivetvManageChannelsByIdSortindex Sets a channel sort index

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvManageChannelsByIdSortindex(ctx context.Context, id string) LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest {
	return LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelQueryResultChannelManagementInfo
func (a *LiveTvServiceAPIService) PostLivetvManageChannelsByIdSortindexExecute(r LiveTvServiceAPIPostLivetvManageChannelsByIdSortindexRequest) (*ModelQueryResultChannelManagementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelQueryResultChannelManagementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvManageChannelsByIdSortindex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Manage/Channels/{Id}/SortIndex"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTVApiSetChannelSortIndex == nil {
		return localVarReturnValue, nil, reportError("modelLiveTVApiSetChannelSortIndex is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTVApiSetChannelSortIndex
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvProgramsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	modelApiBaseItemsRequest *ModelApiBaseItemsRequest
	channelIds *string
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isFolder *bool
	isNews *bool
	isKids *bool
	isSports *bool
	isNew *bool
	isPremiere *bool
	isNewOrPremiere *bool
	isRepeat *bool
	projectToMedia *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	excludeTags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	audioLayouts *string
	videoCodecs *string
	extendedVideoTypes *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	artistStartsWithOrGreater *string
	albumArtistStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// BaseItemsRequest: 
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ModelApiBaseItemsRequest(modelApiBaseItemsRequest ModelApiBaseItemsRequest) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.modelApiBaseItemsRequest = &modelApiBaseItemsRequest
	return r
}

// The channels to return guide information for.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ChannelIds(channelIds string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.channelIds = &channelIds
	return r
}

// Artist or AlbumArtist
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ArtistType(artistType string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MaxOfficialRating(maxOfficialRating string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasThemeSong(hasThemeSong bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasThemeVideo(hasThemeVideo bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasSubtitles(hasSubtitles bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasSpecialFeature(hasSpecialFeature bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasTrailer(hasTrailer bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) AdjacentTo(adjacentTo string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinIndexNumber(minIndexNumber int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinStartDate(minStartDate string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MaxStartDate(maxStartDate string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinEndDate(minEndDate string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MaxEndDate(maxEndDate string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter by minimum number of game players.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinPlayers(minPlayers int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MaxPlayers(maxPlayers int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ParentIndexNumber(parentIndexNumber int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasParentalRating(hasParentalRating bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsHD(isHD bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isHD = &isHD
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsUnaired(isUnaired bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinCommunityRating(minCommunityRating float64) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinCriticRating(minCriticRating float64) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) AiredDuringSeason(airedDuringSeason int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinPremiereDate(minPremiereDate string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinDateLastSaved(minDateLastSaved string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MaxPremiereDate(maxPremiereDate string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasOverview(hasOverview bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasImdbId(hasImdbId bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasTmdbId(hasTmdbId bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasTvdbId(hasTvdbId bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ExcludeItemIds(excludeItemIds string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) StartIndex(startIndex int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Limit(limit int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Recursive(recursive bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.recursive = &recursive
	return r
}

// Enter a search term to perform a search request
func (r LiveTvServiceAPIPostLivetvProgramsRequest) SearchTerm(searchTerm string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending,Descending
func (r LiveTvServiceAPIPostLivetvProgramsRequest) SortOrder(sortOrder string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ParentId(parentId string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Fields(fields string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ExcludeItemTypes(excludeItemTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IncludeItemTypes(includeItemTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) AnyProviderIdEquals(anyProviderIdEquals string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Filters(filters string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsFavorite(isFavorite bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsMovie(isMovie bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for series.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsSeries(isSeries bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for folders.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsFolder(isFolder bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isFolder = &isFolder
	return r
}

// Optional filter for news.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsNews(isNews bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsKids(isKids bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsSports(isSports bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter for IsNew.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsNew(isNew bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isNew = &isNew
	return r
}

// Optional filter for IsPremiere.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsPremiere(isPremiere bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isPremiere = &isPremiere
	return r
}

// Optional filter for IsNewOrPremiere.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsNewOrPremiere(isNewOrPremiere bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isNewOrPremiere = &isNewOrPremiere
	return r
}

// Optional filter for IsRepeat.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsRepeat(isRepeat bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isRepeat = &isRepeat
	return r
}

// ProjectToMedia
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ProjectToMedia(projectToMedia bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.projectToMedia = &projectToMedia
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MediaTypes(mediaTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ImageTypes(imageTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r LiveTvServiceAPIPostLivetvProgramsRequest) SortBy(sortBy string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsPlayed(isPlayed bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Genres(genres string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) OfficialRatings(officialRatings string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Tags(tags string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ExcludeTags(excludeTags string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.excludeTags = &excludeTags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Years(years string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r LiveTvServiceAPIPostLivetvProgramsRequest) EnableImages(enableImages bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r LiveTvServiceAPIPostLivetvProgramsRequest) EnableUserData(enableUserData bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) EnableImageTypes(enableImageTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Person(person string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) PersonIds(personIds string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r LiveTvServiceAPIPostLivetvProgramsRequest) PersonTypes(personTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Studios(studios string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) StudioIds(studioIds string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Artists(artists string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ArtistIds(artistIds string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Albums(albums string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Ids(ids string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) VideoTypes(videoTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Containers(containers string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) AudioCodecs(audioCodecs string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by AudioLayout. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) AudioLayouts(audioLayouts string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.audioLayouts = &audioLayouts
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) VideoCodecs(videoCodecs string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ExtendedVideoTypes(extendedVideoTypes string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.extendedVideoTypes = &extendedVideoTypes
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) SubtitleCodecs(subtitleCodecs string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Path(path string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.path = &path
	return r
}

// User Id
func (r LiveTvServiceAPIPostLivetvProgramsRequest) UserId(userId string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r LiveTvServiceAPIPostLivetvProgramsRequest) MinOfficialRating(minOfficialRating string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsLocked(isLocked bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r LiveTvServiceAPIPostLivetvProgramsRequest) IsPlaceHolder(isPlaceHolder bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r LiveTvServiceAPIPostLivetvProgramsRequest) HasOfficialRating(hasOfficialRating bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) Is3D(is3D bool) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) SeriesStatus(seriesStatus string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) ArtistStartsWithOrGreater(artistStartsWithOrGreater string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.artistStartsWithOrGreater = &artistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) AlbumArtistStartsWithOrGreater(albumArtistStartsWithOrGreater string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.albumArtistStartsWithOrGreater = &albumArtistStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) NameStartsWith(nameStartsWith string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r LiveTvServiceAPIPostLivetvProgramsRequest) NameLessThan(nameLessThan string) LiveTvServiceAPIPostLivetvProgramsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r LiveTvServiceAPIPostLivetvProgramsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvProgramsExecute(r)
}

/*
PostLivetvPrograms Gets available live tv epgs..

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvProgramsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvPrograms(ctx context.Context) LiveTvServiceAPIPostLivetvProgramsRequest {
	return LiveTvServiceAPIPostLivetvProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvProgramsExecute(r LiveTvServiceAPIPostLivetvProgramsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvPrograms")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelApiBaseItemsRequest == nil {
		return nil, reportError("modelApiBaseItemsRequest is required and must be specified")
	}

	if r.channelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelIds", r.channelIds, "")
	}
	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "")
	}
	if r.isFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFolder", r.isFolder, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "")
	}
	if r.isNew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNew", r.isNew, "")
	}
	if r.isPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPremiere", r.isPremiere, "")
	}
	if r.isNewOrPremiere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNewOrPremiere", r.isNewOrPremiere, "")
	}
	if r.isRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsRepeat", r.isRepeat, "")
	}
	if r.projectToMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProjectToMedia", r.projectToMedia, "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "")
	}
	if r.excludeTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeTags", r.excludeTags, "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "")
	}
	if r.audioLayouts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioLayouts", r.audioLayouts, "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "")
	}
	if r.extendedVideoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExtendedVideoTypes", r.extendedVideoTypes, "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.artistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistStartsWithOrGreater", r.artistStartsWithOrGreater, "")
	}
	if r.albumArtistStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AlbumArtistStartsWithOrGreater", r.albumArtistStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelApiBaseItemsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvRecordingsByIdDeleteRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIPostLivetvRecordingsByIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvRecordingsByIdDeleteExecute(r)
}

/*
PostLivetvRecordingsByIdDelete Deletes a live tv recording

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Recording Id
 @return LiveTvServiceAPIPostLivetvRecordingsByIdDeleteRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvRecordingsByIdDelete(ctx context.Context, id string) LiveTvServiceAPIPostLivetvRecordingsByIdDeleteRequest {
	return LiveTvServiceAPIPostLivetvRecordingsByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvRecordingsByIdDeleteExecute(r LiveTvServiceAPIPostLivetvRecordingsByIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvRecordingsByIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{Id}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvSeriestimersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	modelLiveTvSeriesTimerInfo *ModelLiveTvSeriesTimerInfo
}

// SeriesTimerInfo: 
func (r LiveTvServiceAPIPostLivetvSeriestimersRequest) ModelLiveTvSeriesTimerInfo(modelLiveTvSeriesTimerInfo ModelLiveTvSeriesTimerInfo) LiveTvServiceAPIPostLivetvSeriestimersRequest {
	r.modelLiveTvSeriesTimerInfo = &modelLiveTvSeriesTimerInfo
	return r
}

func (r LiveTvServiceAPIPostLivetvSeriestimersRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvSeriestimersExecute(r)
}

/*
PostLivetvSeriestimers Creates a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvSeriestimersRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvSeriestimers(ctx context.Context) LiveTvServiceAPIPostLivetvSeriestimersRequest {
	return LiveTvServiceAPIPostLivetvSeriestimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersExecute(r LiveTvServiceAPIPostLivetvSeriestimersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvSeriestimers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTvSeriesTimerInfo == nil {
		return nil, reportError("modelLiveTvSeriesTimerInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTvSeriesTimerInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvSeriestimersByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
	modelLiveTvSeriesTimerInfo *ModelLiveTvSeriesTimerInfo
}

// SeriesTimerInfo: 
func (r LiveTvServiceAPIPostLivetvSeriestimersByIdRequest) ModelLiveTvSeriesTimerInfo(modelLiveTvSeriesTimerInfo ModelLiveTvSeriesTimerInfo) LiveTvServiceAPIPostLivetvSeriestimersByIdRequest {
	r.modelLiveTvSeriesTimerInfo = &modelLiveTvSeriesTimerInfo
	return r
}

func (r LiveTvServiceAPIPostLivetvSeriestimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvSeriestimersByIdExecute(r)
}

/*
PostLivetvSeriestimersById Updates a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LiveTvServiceAPIPostLivetvSeriestimersByIdRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersById(ctx context.Context, id string) LiveTvServiceAPIPostLivetvSeriestimersByIdRequest {
	return LiveTvServiceAPIPostLivetvSeriestimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersByIdExecute(r LiveTvServiceAPIPostLivetvSeriestimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvSeriestimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTvSeriesTimerInfo == nil {
		return nil, reportError("modelLiveTvSeriesTimerInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTvSeriesTimerInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvSeriestimersByIdDeleteRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIPostLivetvSeriestimersByIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvSeriestimersByIdDeleteExecute(r)
}

/*
PostLivetvSeriestimersByIdDelete Cancels a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return LiveTvServiceAPIPostLivetvSeriestimersByIdDeleteRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersByIdDelete(ctx context.Context, id string) LiveTvServiceAPIPostLivetvSeriestimersByIdDeleteRequest {
	return LiveTvServiceAPIPostLivetvSeriestimersByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersByIdDeleteExecute(r LiveTvServiceAPIPostLivetvSeriestimersByIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvSeriestimersByIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{Id}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvTimersRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	modelLiveTvTimerInfoDto *ModelLiveTvTimerInfoDto
}

// TimerInfoDto: 
func (r LiveTvServiceAPIPostLivetvTimersRequest) ModelLiveTvTimerInfoDto(modelLiveTvTimerInfoDto ModelLiveTvTimerInfoDto) LiveTvServiceAPIPostLivetvTimersRequest {
	r.modelLiveTvTimerInfoDto = &modelLiveTvTimerInfoDto
	return r
}

func (r LiveTvServiceAPIPostLivetvTimersRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTimersExecute(r)
}

/*
PostLivetvTimers Creates a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvTimersRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTimers(ctx context.Context) LiveTvServiceAPIPostLivetvTimersRequest {
	return LiveTvServiceAPIPostLivetvTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTimersExecute(r LiveTvServiceAPIPostLivetvTimersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTimers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTvTimerInfoDto == nil {
		return nil, reportError("modelLiveTvTimerInfoDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTvTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvTimersByIdRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
	modelLiveTvTimerInfoDto *ModelLiveTvTimerInfoDto
}

// TimerInfoDto: 
func (r LiveTvServiceAPIPostLivetvTimersByIdRequest) ModelLiveTvTimerInfoDto(modelLiveTvTimerInfoDto ModelLiveTvTimerInfoDto) LiveTvServiceAPIPostLivetvTimersByIdRequest {
	r.modelLiveTvTimerInfoDto = &modelLiveTvTimerInfoDto
	return r
}

func (r LiveTvServiceAPIPostLivetvTimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTimersByIdExecute(r)
}

/*
PostLivetvTimersById Updates a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LiveTvServiceAPIPostLivetvTimersByIdRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTimersById(ctx context.Context, id string) LiveTvServiceAPIPostLivetvTimersByIdRequest {
	return LiveTvServiceAPIPostLivetvTimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTimersByIdExecute(r LiveTvServiceAPIPostLivetvTimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTvTimerInfoDto == nil {
		return nil, reportError("modelLiveTvTimerInfoDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTvTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvTimersByIdDeleteRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIPostLivetvTimersByIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTimersByIdDeleteExecute(r)
}

/*
PostLivetvTimersByIdDelete Cancels a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return LiveTvServiceAPIPostLivetvTimersByIdDeleteRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTimersByIdDelete(ctx context.Context, id string) LiveTvServiceAPIPostLivetvTimersByIdDeleteRequest {
	return LiveTvServiceAPIPostLivetvTimersByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTimersByIdDeleteExecute(r LiveTvServiceAPIPostLivetvTimersByIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTimersByIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{Id}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvTunerhostsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	modelLiveTvTunerHostInfo *ModelLiveTvTunerHostInfo
}

// TunerHostInfo: 
func (r LiveTvServiceAPIPostLivetvTunerhostsRequest) ModelLiveTvTunerHostInfo(modelLiveTvTunerHostInfo ModelLiveTvTunerHostInfo) LiveTvServiceAPIPostLivetvTunerhostsRequest {
	r.modelLiveTvTunerHostInfo = &modelLiveTvTunerHostInfo
	return r
}

func (r LiveTvServiceAPIPostLivetvTunerhostsRequest) Execute() (*ModelLiveTvTunerHostInfo, *http.Response, error) {
	return r.ApiService.PostLivetvTunerhostsExecute(r)
}

/*
PostLivetvTunerhosts Adds a tuner host

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvTunerhostsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTunerhosts(ctx context.Context) LiveTvServiceAPIPostLivetvTunerhostsRequest {
	return LiveTvServiceAPIPostLivetvTunerhostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelLiveTvTunerHostInfo
func (a *LiveTvServiceAPIService) PostLivetvTunerhostsExecute(r LiveTvServiceAPIPostLivetvTunerhostsRequest) (*ModelLiveTvTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelLiveTvTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTunerhosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelLiveTvTunerHostInfo == nil {
		return localVarReturnValue, nil, reportError("modelLiveTvTunerHostInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTvTunerHostInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id *string
}

// Tuner host id
func (r LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest) Id(id string) LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest {
	r.id = &id
	return r
}

func (r LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTunerhostsDeleteExecute(r)
}

/*
PostLivetvTunerhostsDelete Deletes a tuner host

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTunerhostsDelete(ctx context.Context) LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest {
	return LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTunerhostsDeleteExecute(r LiveTvServiceAPIPostLivetvTunerhostsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTunerhostsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts/Delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPostLivetvTunersByIdResetRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	id string
}

func (r LiveTvServiceAPIPostLivetvTunersByIdResetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTunersByIdResetExecute(r)
}

/*
PostLivetvTunersByIdReset Resets a tv tuner

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Tuner Id
 @return LiveTvServiceAPIPostLivetvTunersByIdResetRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTunersByIdReset(ctx context.Context, id string) LiveTvServiceAPIPostLivetvTunersByIdResetRequest {
	return LiveTvServiceAPIPostLivetvTunersByIdResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTunersByIdResetExecute(r LiveTvServiceAPIPostLivetvTunersByIdResetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTunersByIdReset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/{Id}/Reset"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
}

// Provider id
func (r LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest) ProviderId(providerId string) LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutLivetvChannelmappingoptionsExecute(r)
}

/*
PutLivetvChannelmappingoptions Method for PutLivetvChannelmappingoptions

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) PutLivetvChannelmappingoptions(ctx context.Context) LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest {
	return LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PutLivetvChannelmappingoptionsExecute(r LiveTvServiceAPIPutLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PutLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvServiceAPIPutLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService *LiveTvServiceAPIService
	providerId *string
	modelLiveTVApiSetChannelMapping *ModelLiveTVApiSetChannelMapping
}

// Provider id
func (r LiveTvServiceAPIPutLivetvChannelmappingsRequest) ProviderId(providerId string) LiveTvServiceAPIPutLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

// SetChannelMapping
func (r LiveTvServiceAPIPutLivetvChannelmappingsRequest) ModelLiveTVApiSetChannelMapping(modelLiveTVApiSetChannelMapping ModelLiveTVApiSetChannelMapping) LiveTvServiceAPIPutLivetvChannelmappingsRequest {
	r.modelLiveTVApiSetChannelMapping = &modelLiveTVApiSetChannelMapping
	return r
}

func (r LiveTvServiceAPIPutLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutLivetvChannelmappingsExecute(r)
}

/*
PutLivetvChannelmappings Method for PutLivetvChannelmappings

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvServiceAPIPutLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) PutLivetvChannelmappings(ctx context.Context) LiveTvServiceAPIPutLivetvChannelmappingsRequest {
	return LiveTvServiceAPIPutLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PutLivetvChannelmappingsExecute(r LiveTvServiceAPIPutLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PutLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}
	if r.modelLiveTVApiSetChannelMapping == nil {
		return nil, reportError("modelLiveTVApiSetChannelMapping is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelLiveTVApiSetChannelMapping
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

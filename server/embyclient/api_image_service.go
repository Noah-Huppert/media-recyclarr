/*
Emby Server REST API (BETA)

Explore the Emby Server API

API version: 4.8.0.61
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package embyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ImageServiceAPIService ImageServiceAPI service
type ImageServiceAPIService service

type ImageServiceAPIDeleteItemsByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index *int32
}

// Image Index
func (r ImageServiceAPIDeleteItemsByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIDeleteItemsByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIDeleteItemsByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemsByIdImagesByTypeExecute(r)
}

/*
DeleteItemsByIdImagesByType Method for DeleteItemsByIdImagesByType

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @return ImageServiceAPIDeleteItemsByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) DeleteItemsByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIDeleteItemsByIdImagesByTypeRequest {
	return ImageServiceAPIDeleteItemsByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) DeleteItemsByIdImagesByTypeExecute(r ImageServiceAPIDeleteItemsByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.DeleteItemsByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIDeleteItemsByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
}

func (r ImageServiceAPIDeleteItemsByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemsByIdImagesByTypeByIndexExecute(r)
}

/*
DeleteItemsByIdImagesByTypeByIndex Method for DeleteItemsByIdImagesByTypeByIndex

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIDeleteItemsByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) DeleteItemsByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIDeleteItemsByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIDeleteItemsByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) DeleteItemsByIdImagesByTypeByIndexExecute(r ImageServiceAPIDeleteItemsByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.DeleteItemsByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIDeleteUsersByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index *int32
}

// Image Index
func (r ImageServiceAPIDeleteUsersByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIDeleteUsersByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIDeleteUsersByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUsersByIdImagesByTypeExecute(r)
}

/*
DeleteUsersByIdImagesByType Method for DeleteUsersByIdImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @return ImageServiceAPIDeleteUsersByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) DeleteUsersByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIDeleteUsersByIdImagesByTypeRequest {
	return ImageServiceAPIDeleteUsersByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) DeleteUsersByIdImagesByTypeExecute(r ImageServiceAPIDeleteUsersByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.DeleteUsersByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIDeleteUsersByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
}

func (r ImageServiceAPIDeleteUsersByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUsersByIdImagesByTypeByIndexExecute(r)
}

/*
DeleteUsersByIdImagesByTypeByIndex Method for DeleteUsersByIdImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIDeleteUsersByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) DeleteUsersByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIDeleteUsersByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIDeleteUsersByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) DeleteUsersByIdImagesByTypeByIndexExecute(r ImageServiceAPIDeleteUsersByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.DeleteUsersByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetArtistsByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) Format(format string) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetArtistsByNameImagesByTypeExecute(r)
}

/*
GetArtistsByNameImagesByType Method for GetArtistsByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIGetArtistsByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetArtistsByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIGetArtistsByNameImagesByTypeRequest {
	return ImageServiceAPIGetArtistsByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetArtistsByNameImagesByTypeExecute(r ImageServiceAPIGetArtistsByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetArtistsByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetArtistsByNameImagesByTypeByIndexExecute(r)
}

/*
GetArtistsByNameImagesByTypeByIndex Method for GetArtistsByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetArtistsByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetArtistsByNameImagesByTypeByIndexExecute(r ImageServiceAPIGetArtistsByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetArtistsByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetGamegenresByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) Format(format string) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetGamegenresByNameImagesByTypeExecute(r)
}

/*
GetGamegenresByNameImagesByType Method for GetGamegenresByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIGetGamegenresByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetGamegenresByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIGetGamegenresByNameImagesByTypeRequest {
	return ImageServiceAPIGetGamegenresByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetGamegenresByNameImagesByTypeExecute(r ImageServiceAPIGetGamegenresByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetGamegenresByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/GameGenres/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetGamegenresByNameImagesByTypeByIndexExecute(r)
}

/*
GetGamegenresByNameImagesByTypeByIndex Method for GetGamegenresByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetGamegenresByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetGamegenresByNameImagesByTypeByIndexExecute(r ImageServiceAPIGetGamegenresByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetGamegenresByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/GameGenres/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetGenresByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) Format(format string) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetGenresByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetGenresByNameImagesByTypeExecute(r)
}

/*
GetGenresByNameImagesByType Method for GetGenresByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIGetGenresByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetGenresByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIGetGenresByNameImagesByTypeRequest {
	return ImageServiceAPIGetGenresByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetGenresByNameImagesByTypeExecute(r ImageServiceAPIGetGenresByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetGenresByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetGenresByNameImagesByTypeByIndexExecute(r)
}

/*
GetGenresByNameImagesByTypeByIndex Method for GetGenresByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetGenresByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetGenresByNameImagesByTypeByIndexExecute(r ImageServiceAPIGetGenresByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetGenresByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetItemsByIdImagesRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
}

func (r ImageServiceAPIGetItemsByIdImagesRequest) Execute() ([]ModelImageInfo, *http.Response, error) {
	return r.ApiService.GetItemsByIdImagesExecute(r)
}

/*
GetItemsByIdImages Gets information about an item's images

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ImageServiceAPIGetItemsByIdImagesRequest
*/
func (a *ImageServiceAPIService) GetItemsByIdImages(ctx context.Context, id string) ImageServiceAPIGetItemsByIdImagesRequest {
	return ImageServiceAPIGetItemsByIdImagesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ModelImageInfo
func (a *ImageServiceAPIService) GetItemsByIdImagesExecute(r ImageServiceAPIGetItemsByIdImagesRequest) ([]ModelImageInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelImageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetItemsByIdImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageServiceAPIGetItemsByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) Width(width int32) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) Height(height int32) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) Format(format string) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetItemsByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsByIdImagesByTypeExecute(r)
}

/*
GetItemsByIdImagesByType Method for GetItemsByIdImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @return ImageServiceAPIGetItemsByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetItemsByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIGetItemsByIdImagesByTypeRequest {
	return ImageServiceAPIGetItemsByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetItemsByIdImagesByTypeExecute(r ImageServiceAPIGetItemsByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetItemsByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsByIdImagesByTypeByIndexExecute(r)
}

/*
GetItemsByIdImagesByTypeByIndex Method for GetItemsByIdImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetItemsByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetItemsByIdImagesByTypeByIndexExecute(r ImageServiceAPIGetItemsByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetItemsByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	percentPlayed int32
	unPlayedCount int32
	id string
	maxWidth int32
	maxHeight int32
	tag string
	format string
	type_ ModelImageType
	index int32
	width *int32
	height *int32
	quality *int32
	cropWhitespace *bool
	enableImageEnhancers *bool
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The fixed image width to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Width(width int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Height(height int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Quality(quality int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.quality = &quality
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountExecute(r)
}

/*
GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount Method for GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param percentPlayed
 @param unPlayedCount
 @param id Item Id
 @param maxWidth The maximum image width to return.
 @param maxHeight The maximum image height to return.
 @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 @param format Determines the output foramt of the image - original,gif,jpg,png
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest
*/
func (a *ImageServiceAPIService) GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(ctx context.Context, percentPlayed int32, unPlayedCount int32, id string, maxWidth int32, maxHeight int32, tag string, format string, type_ ModelImageType, index int32) ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	return ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest{
		ApiService: a,
		ctx: ctx,
		percentPlayed: percentPlayed,
		unPlayedCount: unPlayedCount,
		id: id,
		maxWidth: maxWidth,
		maxHeight: maxHeight,
		tag: tag,
		format: format,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountExecute(r ImageServiceAPIGetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"PercentPlayed"+"}", url.PathEscape(parameterValueToString(r.percentPlayed, "percentPlayed")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UnPlayedCount"+"}", url.PathEscape(parameterValueToString(r.unPlayedCount, "unPlayedCount")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MaxWidth"+"}", url.PathEscape(parameterValueToString(r.maxWidth, "maxWidth")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MaxHeight"+"}", url.PathEscape(parameterValueToString(r.maxHeight, "maxHeight")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Tag"+"}", url.PathEscape(parameterValueToString(r.tag, "tag")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) Format(format string) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetMusicgenresByNameImagesByTypeExecute(r)
}

/*
GetMusicgenresByNameImagesByType Method for GetMusicgenresByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetMusicgenresByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest {
	return ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetMusicgenresByNameImagesByTypeExecute(r ImageServiceAPIGetMusicgenresByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetMusicgenresByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetMusicgenresByNameImagesByTypeByIndexExecute(r)
}

/*
GetMusicgenresByNameImagesByTypeByIndex Method for GetMusicgenresByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetMusicgenresByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetMusicgenresByNameImagesByTypeByIndexExecute(r ImageServiceAPIGetMusicgenresByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetMusicgenresByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetPersonsByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) Format(format string) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPersonsByNameImagesByTypeExecute(r)
}

/*
GetPersonsByNameImagesByType Method for GetPersonsByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIGetPersonsByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetPersonsByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIGetPersonsByNameImagesByTypeRequest {
	return ImageServiceAPIGetPersonsByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetPersonsByNameImagesByTypeExecute(r ImageServiceAPIGetPersonsByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetPersonsByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPersonsByNameImagesByTypeByIndexExecute(r)
}

/*
GetPersonsByNameImagesByTypeByIndex Method for GetPersonsByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetPersonsByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetPersonsByNameImagesByTypeByIndexExecute(r ImageServiceAPIGetPersonsByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetPersonsByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetStudiosByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) Format(format string) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetStudiosByNameImagesByTypeExecute(r)
}

/*
GetStudiosByNameImagesByType Method for GetStudiosByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIGetStudiosByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetStudiosByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIGetStudiosByNameImagesByTypeRequest {
	return ImageServiceAPIGetStudiosByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetStudiosByNameImagesByTypeExecute(r ImageServiceAPIGetStudiosByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetStudiosByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetStudiosByNameImagesByTypeByIndexExecute(r)
}

/*
GetStudiosByNameImagesByTypeByIndex Method for GetStudiosByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetStudiosByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetStudiosByNameImagesByTypeByIndexExecute(r ImageServiceAPIGetStudiosByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetStudiosByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetUsersByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) Width(width int32) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) Height(height int32) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) Quality(quality int32) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) Tag(tag string) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) Format(format string) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIGetUsersByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUsersByIdImagesByTypeExecute(r)
}

/*
GetUsersByIdImagesByType Method for GetUsersByIdImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @return ImageServiceAPIGetUsersByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) GetUsersByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIGetUsersByIdImagesByTypeRequest {
	return ImageServiceAPIGetUsersByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetUsersByIdImagesByTypeExecute(r ImageServiceAPIGetUsersByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetUsersByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUsersByIdImagesByTypeByIndexExecute(r)
}

/*
GetUsersByIdImagesByTypeByIndex Method for GetUsersByIdImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) GetUsersByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) GetUsersByIdImagesByTypeByIndexExecute(r ImageServiceAPIGetUsersByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.GetUsersByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadArtistsByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) Format(format string) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadArtistsByNameImagesByTypeExecute(r)
}

/*
HeadArtistsByNameImagesByType Method for HeadArtistsByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIHeadArtistsByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadArtistsByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIHeadArtistsByNameImagesByTypeRequest {
	return ImageServiceAPIHeadArtistsByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadArtistsByNameImagesByTypeExecute(r ImageServiceAPIHeadArtistsByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadArtistsByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadArtistsByNameImagesByTypeByIndexExecute(r)
}

/*
HeadArtistsByNameImagesByTypeByIndex Method for HeadArtistsByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadArtistsByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadArtistsByNameImagesByTypeByIndexExecute(r ImageServiceAPIHeadArtistsByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadArtistsByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) Format(format string) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadGamegenresByNameImagesByTypeExecute(r)
}

/*
HeadGamegenresByNameImagesByType Method for HeadGamegenresByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadGamegenresByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest {
	return ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadGamegenresByNameImagesByTypeExecute(r ImageServiceAPIHeadGamegenresByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadGamegenresByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/GameGenres/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadGamegenresByNameImagesByTypeByIndexExecute(r)
}

/*
HeadGamegenresByNameImagesByTypeByIndex Method for HeadGamegenresByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadGamegenresByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadGamegenresByNameImagesByTypeByIndexExecute(r ImageServiceAPIHeadGamegenresByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadGamegenresByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/GameGenres/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadGenresByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) Format(format string) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadGenresByNameImagesByTypeExecute(r)
}

/*
HeadGenresByNameImagesByType Method for HeadGenresByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIHeadGenresByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadGenresByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIHeadGenresByNameImagesByTypeRequest {
	return ImageServiceAPIHeadGenresByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadGenresByNameImagesByTypeExecute(r ImageServiceAPIHeadGenresByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadGenresByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadGenresByNameImagesByTypeByIndexExecute(r)
}

/*
HeadGenresByNameImagesByTypeByIndex Method for HeadGenresByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadGenresByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadGenresByNameImagesByTypeByIndexExecute(r ImageServiceAPIHeadGenresByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadGenresByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadItemsByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) Format(format string) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadItemsByIdImagesByTypeExecute(r)
}

/*
HeadItemsByIdImagesByType Method for HeadItemsByIdImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @return ImageServiceAPIHeadItemsByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadItemsByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIHeadItemsByIdImagesByTypeRequest {
	return ImageServiceAPIHeadItemsByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadItemsByIdImagesByTypeExecute(r ImageServiceAPIHeadItemsByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadItemsByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadItemsByIdImagesByTypeByIndexExecute(r)
}

/*
HeadItemsByIdImagesByTypeByIndex Method for HeadItemsByIdImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadItemsByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadItemsByIdImagesByTypeByIndexExecute(r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadItemsByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	percentPlayed int32
	unPlayedCount int32
	id string
	maxWidth int32
	maxHeight int32
	tag string
	format string
	type_ ModelImageType
	index int32
	width *int32
	height *int32
	quality *int32
	cropWhitespace *bool
	enableImageEnhancers *bool
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The fixed image width to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Width(width int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Height(height int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Quality(quality int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.quality = &quality
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountExecute(r)
}

/*
HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount Method for HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param percentPlayed
 @param unPlayedCount
 @param id Item Id
 @param maxWidth The maximum image width to return.
 @param maxHeight The maximum image height to return.
 @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 @param format Determines the output foramt of the image - original,gif,jpg,png
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest
*/
func (a *ImageServiceAPIService) HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(ctx context.Context, percentPlayed int32, unPlayedCount int32, id string, maxWidth int32, maxHeight int32, tag string, format string, type_ ModelImageType, index int32) ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest {
	return ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest{
		ApiService: a,
		ctx: ctx,
		percentPlayed: percentPlayed,
		unPlayedCount: unPlayedCount,
		id: id,
		maxWidth: maxWidth,
		maxHeight: maxHeight,
		tag: tag,
		format: format,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountExecute(r ImageServiceAPIHeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"PercentPlayed"+"}", url.PathEscape(parameterValueToString(r.percentPlayed, "percentPlayed")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UnPlayedCount"+"}", url.PathEscape(parameterValueToString(r.unPlayedCount, "unPlayedCount")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MaxWidth"+"}", url.PathEscape(parameterValueToString(r.maxWidth, "maxWidth")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MaxHeight"+"}", url.PathEscape(parameterValueToString(r.maxHeight, "maxHeight")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Tag"+"}", url.PathEscape(parameterValueToString(r.tag, "tag")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) Format(format string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadMusicgenresByNameImagesByTypeExecute(r)
}

/*
HeadMusicgenresByNameImagesByType Method for HeadMusicgenresByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadMusicgenresByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest {
	return ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadMusicgenresByNameImagesByTypeExecute(r ImageServiceAPIHeadMusicgenresByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadMusicgenresByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadMusicgenresByNameImagesByTypeByIndexExecute(r)
}

/*
HeadMusicgenresByNameImagesByTypeByIndex Method for HeadMusicgenresByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadMusicgenresByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadMusicgenresByNameImagesByTypeByIndexExecute(r ImageServiceAPIHeadMusicgenresByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadMusicgenresByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadPersonsByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) Format(format string) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadPersonsByNameImagesByTypeExecute(r)
}

/*
HeadPersonsByNameImagesByType Method for HeadPersonsByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIHeadPersonsByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadPersonsByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIHeadPersonsByNameImagesByTypeRequest {
	return ImageServiceAPIHeadPersonsByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadPersonsByNameImagesByTypeExecute(r ImageServiceAPIHeadPersonsByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadPersonsByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadPersonsByNameImagesByTypeByIndexExecute(r)
}

/*
HeadPersonsByNameImagesByTypeByIndex Method for HeadPersonsByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadPersonsByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadPersonsByNameImagesByTypeByIndexExecute(r ImageServiceAPIHeadPersonsByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadPersonsByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadStudiosByNameImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) Format(format string) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadStudiosByNameImagesByTypeExecute(r)
}

/*
HeadStudiosByNameImagesByType Method for HeadStudiosByNameImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @return ImageServiceAPIHeadStudiosByNameImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadStudiosByNameImagesByType(ctx context.Context, name string, type_ ModelImageType) ImageServiceAPIHeadStudiosByNameImagesByTypeRequest {
	return ImageServiceAPIHeadStudiosByNameImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadStudiosByNameImagesByTypeExecute(r ImageServiceAPIHeadStudiosByNameImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadStudiosByNameImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{Name}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	name string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadStudiosByNameImagesByTypeByIndexExecute(r)
}

/*
HeadStudiosByNameImagesByTypeByIndex Method for HeadStudiosByNameImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Item name
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadStudiosByNameImagesByTypeByIndex(ctx context.Context, name string, type_ ModelImageType, index int32) ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadStudiosByNameImagesByTypeByIndexExecute(r ImageServiceAPIHeadStudiosByNameImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadStudiosByNameImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{Name}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadUsersByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
	index *int32
}

// The maximum image width to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) Width(width int32) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) Height(height int32) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) Quality(quality int32) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) Tag(tag string) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) Format(format string) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.keepAnimation = &keepAnimation
	return r
}

// Image Index
func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadUsersByIdImagesByTypeExecute(r)
}

/*
HeadUsersByIdImagesByType Method for HeadUsersByIdImagesByType

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @return ImageServiceAPIHeadUsersByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) HeadUsersByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIHeadUsersByIdImagesByTypeRequest {
	return ImageServiceAPIHeadUsersByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadUsersByIdImagesByTypeExecute(r ImageServiceAPIHeadUsersByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadUsersByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	tag *string
	cropWhitespace *bool
	enableImageEnhancers *bool
	format *string
	backgroundColor *string
	foregroundLayer *string
	autoOrient *bool
	keepAnimation *bool
}

// The maximum image width to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) MaxWidth(maxWidth int32) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) MaxHeight(maxHeight int32) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) Width(width int32) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) Height(height int32) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.height = &height
	return r
}

// Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) Quality(quality int32) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.quality = &quality
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) Tag(tag string) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.tag = &tag
	return r
}

// Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) CropWhitespace(cropWhitespace bool) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.cropWhitespace = &cropWhitespace
	return r
}

// Enable or disable image enhancers such as cover art.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) EnableImageEnhancers(enableImageEnhancers bool) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.enableImageEnhancers = &enableImageEnhancers
	return r
}

// Determines the output foramt of the image - original,gif,jpg,png
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) Format(format string) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.format = &format
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) BackgroundColor(backgroundColor string) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) ForegroundLayer(foregroundLayer string) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Set to true to force normalization of orientation in the event the renderer does not support it.
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) AutoOrient(autoOrient bool) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.autoOrient = &autoOrient
	return r
}

// Set to true to retain image animation (when supported).
func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) KeepAnimation(keepAnimation bool) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	r.keepAnimation = &keepAnimation
	return r
}

func (r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadUsersByIdImagesByTypeByIndexExecute(r)
}

/*
HeadUsersByIdImagesByTypeByIndex Method for HeadUsersByIdImagesByTypeByIndex

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) HeadUsersByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) HeadUsersByIdImagesByTypeByIndexExecute(r ImageServiceAPIHeadUsersByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.HeadUsersByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxHeight", r.maxHeight, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Width", r.width, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Height", r.height, "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Quality", r.quality, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tag", r.tag, "")
	}
	if r.cropWhitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CropWhitespace", r.cropWhitespace, "")
	}
	if r.enableImageEnhancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageEnhancers", r.enableImageEnhancers, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "BackgroundColor", r.backgroundColor, "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ForegroundLayer", r.foregroundLayer, "")
	}
	if r.autoOrient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AutoOrient", r.autoOrient, "")
	}
	if r.keepAnimation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeepAnimation", r.keepAnimation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostItemsByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	body *os.File
	index *int32
}

// Binary stream
func (r ImageServiceAPIPostItemsByIdImagesByTypeRequest) Body(body *os.File) ImageServiceAPIPostItemsByIdImagesByTypeRequest {
	r.body = body
	return r
}

// Image Index
func (r ImageServiceAPIPostItemsByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIPostItemsByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIPostItemsByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdImagesByTypeExecute(r)
}

/*
PostItemsByIdImagesByType Uploads an image for an item, must be base64 encoded.

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @return ImageServiceAPIPostItemsByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) PostItemsByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIPostItemsByIdImagesByTypeRequest {
	return ImageServiceAPIPostItemsByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeExecute(r ImageServiceAPIPostItemsByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostItemsByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	body *os.File
}

// Binary stream
func (r ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest) Body(body *os.File) ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest {
	r.body = body
	return r
}

func (r ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdImagesByTypeByIndexExecute(r)
}

/*
PostItemsByIdImagesByTypeByIndex Uploads an image for an item, must be base64 encoded.

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndexExecute(r ImageServiceAPIPostItemsByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostItemsByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostItemsByIdImagesByTypeByIndexDeleteRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
}

func (r ImageServiceAPIPostItemsByIdImagesByTypeByIndexDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdImagesByTypeByIndexDeleteExecute(r)
}

/*
PostItemsByIdImagesByTypeByIndexDelete Method for PostItemsByIdImagesByTypeByIndexDelete

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIPostItemsByIdImagesByTypeByIndexDeleteRequest
*/
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndexDelete(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIPostItemsByIdImagesByTypeByIndexDeleteRequest {
	return ImageServiceAPIPostItemsByIdImagesByTypeByIndexDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndexDeleteExecute(r ImageServiceAPIPostItemsByIdImagesByTypeByIndexDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostItemsByIdImagesByTypeByIndexDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	newIndex *int32
}

// The new image index
func (r ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest) NewIndex(newIndex int32) ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest {
	r.newIndex = &newIndex
	return r
}

func (r ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdImagesByTypeByIndexIndexExecute(r)
}

/*
PostItemsByIdImagesByTypeByIndexIndex Updates the index for an item image

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest
*/
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndexIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest {
	return ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndexIndexExecute(r ImageServiceAPIPostItemsByIdImagesByTypeByIndexIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostItemsByIdImagesByTypeByIndexIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}/Index"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newIndex == nil {
		return nil, reportError("newIndex is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "NewIndex", r.newIndex, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	url *string
}

// The url for the new image
func (r ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest) Url(url string) ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest {
	r.url = &url
	return r
}

func (r ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdImagesByTypeByIndexUrlExecute(r)
}

/*
PostItemsByIdImagesByTypeByIndexUrl Updates the index for an item image

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest
*/
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndexUrl(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest {
	return ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeByIndexUrlExecute(r ImageServiceAPIPostItemsByIdImagesByTypeByIndexUrlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostItemsByIdImagesByTypeByIndexUrl")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/{Index}/Url"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return nil, reportError("url is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Url", r.url, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index *int32
}

// Image Index
func (r ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest) Index(index int32) ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostItemsByIdImagesByTypeDeleteExecute(r)
}

/*
PostItemsByIdImagesByTypeDelete Method for PostItemsByIdImagesByTypeDelete

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @param type_ Image Type
 @return ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest
*/
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeDelete(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest {
	return ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostItemsByIdImagesByTypeDeleteExecute(r ImageServiceAPIPostItemsByIdImagesByTypeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostItemsByIdImagesByTypeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Images/{Type}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostUsersByIdImagesByTypeRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	body *os.File
	index *int32
}

// Binary stream
func (r ImageServiceAPIPostUsersByIdImagesByTypeRequest) Body(body *os.File) ImageServiceAPIPostUsersByIdImagesByTypeRequest {
	r.body = body
	return r
}

// Image Index
func (r ImageServiceAPIPostUsersByIdImagesByTypeRequest) Index(index int32) ImageServiceAPIPostUsersByIdImagesByTypeRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIPostUsersByIdImagesByTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdImagesByTypeExecute(r)
}

/*
PostUsersByIdImagesByType Uploads an image for an item, must be base64 encoded.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @return ImageServiceAPIPostUsersByIdImagesByTypeRequest
*/
func (a *ImageServiceAPIService) PostUsersByIdImagesByType(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIPostUsersByIdImagesByTypeRequest {
	return ImageServiceAPIPostUsersByIdImagesByTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostUsersByIdImagesByTypeExecute(r ImageServiceAPIPostUsersByIdImagesByTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostUsersByIdImagesByType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
	body *os.File
}

// Binary stream
func (r ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest) Body(body *os.File) ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest {
	r.body = body
	return r
}

func (r ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdImagesByTypeByIndexExecute(r)
}

/*
PostUsersByIdImagesByTypeByIndex Uploads an image for an item, must be base64 encoded.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest
*/
func (a *ImageServiceAPIService) PostUsersByIdImagesByTypeByIndex(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest {
	return ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostUsersByIdImagesByTypeByIndexExecute(r ImageServiceAPIPostUsersByIdImagesByTypeByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostUsersByIdImagesByTypeByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}/{Index}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostUsersByIdImagesByTypeByIndexDeleteRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index int32
}

func (r ImageServiceAPIPostUsersByIdImagesByTypeByIndexDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdImagesByTypeByIndexDeleteExecute(r)
}

/*
PostUsersByIdImagesByTypeByIndexDelete Method for PostUsersByIdImagesByTypeByIndexDelete

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @param index Image Index
 @return ImageServiceAPIPostUsersByIdImagesByTypeByIndexDeleteRequest
*/
func (a *ImageServiceAPIService) PostUsersByIdImagesByTypeByIndexDelete(ctx context.Context, id string, type_ ModelImageType, index int32) ImageServiceAPIPostUsersByIdImagesByTypeByIndexDeleteRequest {
	return ImageServiceAPIPostUsersByIdImagesByTypeByIndexDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
		index: index,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostUsersByIdImagesByTypeByIndexDeleteExecute(r ImageServiceAPIPostUsersByIdImagesByTypeByIndexDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostUsersByIdImagesByTypeByIndexDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}/{Index}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest struct {
	ctx context.Context
	ApiService *ImageServiceAPIService
	id string
	type_ ModelImageType
	index *int32
}

// Image Index
func (r ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest) Index(index int32) ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest {
	r.index = &index
	return r
}

func (r ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdImagesByTypeDeleteExecute(r)
}

/*
PostUsersByIdImagesByTypeDelete Method for PostUsersByIdImagesByTypeDelete

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id User Id
 @param type_ Image Type
 @return ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest
*/
func (a *ImageServiceAPIService) PostUsersByIdImagesByTypeDelete(ctx context.Context, id string, type_ ModelImageType) ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest {
	return ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		type_: type_,
	}
}

// Execute executes the request
func (a *ImageServiceAPIService) PostUsersByIdImagesByTypeDeleteExecute(r ImageServiceAPIPostUsersByIdImagesByTypeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageServiceAPIService.PostUsersByIdImagesByTypeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Images/{Type}/Delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
